%-----------------------------------------------------------------------------------------------
%		\COMPdataFormatManagement{} Design
%-----------------------------------------------------------------------------------------------

\section{\COMPdataFormatManagement{} Design}
\label{sec:COMPdataFormatsDesign}

In this section, the design of the component \COMPdataFormatManagement{} is described. Basic task of the component is to describe the structure of a container or metadata format in a way that is useful for parsing them generically.

% =======================================================================================================
\subsection{Format Comparison}%
\label{sec:FormatComparison}%

Before any real design decisions can be found, we have to look what the formats are that we try to generically describe with the \COMPdataFormatManagement{} component. The main source of this whole chapter is \cite{MC17}.

We fully focus on the following data formats here, ignoring any other possible formats as out of scope:
\begin{itemize}
\item Multimedia container formats: Ogg, QuickTime, MPEG Layer I Elementary Stream (for MP3), Matroska, RIFF
\item Metadata container formats: ID3v1 and ID3v1.1, ID3v2.2, ID3v2.3, ID3v2.4, VorbisComment, Lyrics3v1, Lyrics3v1, APEv1 and APEv2
\end{itemize}

As first introduction, we have to compare those formats according to their most important structural aspects. These aspects are as follows:
\begin{itemize}
\item Basic encoding they use: \textbf{Byte orders} and \textbf{character encodings} supported
\item Building blocks: What are the \textbf{containers} in this format? Are there other sub-structures? Can they be embedded in each other? Is there a hierarchical structure with arbitrary nesting? For metadata container formats, we call the elements actually holding the metadata \emph{attributes}, which is nothing else than a special case of a container.
\item Headers and Footers: Despite the payload, are there \textbf{headers} and/or \textbf{footers} in the containers or attributes? Are they fixed or variable size?
\item Lengths of containers: How is the \textbf{length of containers} or of their payload defined?
\item Lengths of attributes: How is the \textbf{length of attributes} for metadata container formats defined?
\item Padding: Does the format have some special way of supporting \textbf{padding}?
\end{itemize}

The following table provides all these properties for multimedia container formats, skipping attribute topics:

TODO Table for multimedia formats
tab:DFcompareMult

The following table compares these properties for the metadata container formats considered:

TODO Table for metadata formats
tab:DFcompareMeta

Note that ID3v2x is a very special format in multiple dimensions: It is incredibly overloaded with a lot of features you might never dare dream to use, say: over-designed. It offers e.g. support for encryption, grouping, compression of tags, embedded lyrics or audio guide codec data which basically contain spoken versions of the metadata stored and other things. On top of that, it has a strange conversion scheme called the \emph{unsynchronization scheme}. 

% =======================================================================================================
\subsection{The Container Metamodel}%
\label{sec:TheContainerMetamodel}%

In order to give a feasible model of the structure of a container format (which includes metadata container formats), a metamodel of the typical data structure of a container format is developed here. 

The metamodel is ultimately shown in the following figure, the corresponding design decisions will follow:

\begin{figure}[htbp]
\centering
\includegraphics[width=1.00\linewidth]{figures/II_GeneralModel.pdf}
\caption{The container metamodel}
\label{fig:II_GeneralModel}
\end{figure}

%%%% DD --> %%%%
\DD{dd:500}
{% Title
Containers as basic top-level unit, containing nested containers
}
{% Short description
All data that can be processed by \LibName{} consists of containers. A container is a sequence of bytes with a specific structure belonging to exactly one container data format. However, consecutive containers might belong to different data formats.

In addition, a container - as the name suggests - contains other data. This data might be containers of the same format again. The nesting might be arbitrarily deep. A nested container is able to contain data of other formats. 
}
{% Rationale
Every format considered here has such basic building blocks, called differently in each format specification (atom, frame, page, element, item, tag etc.). The same file or media stream might consist of containers belonging to different formats. One example is an MP3 file with an ID3v2 tag. See also \cite{MC17}, part IV for more details.

Most of the supported data formats have some notion of nesting child containers (or, for metadata formats: attributes) within parent containers. Those child containers have either exactly the same stucture as the top-level containers, or they differ slightly. Some formats such as RIFF explicitly define specific containers that embed data belonging to other metadata formats. 
}
{% Disadvantages
No disadvantages known
}
%%%% <-- DD %%%%

How are these containers structured in detail?

%%%% DD --> %%%%
\DD{dd:501}
{% Title
A container consists of an optional \textbf{header}, \textbf{payload} and an optional \textbf{footer}
}
{% Short description
Every container - no matter which data format - follows the same basic structure: One or more optional headers start the container's byte sequence. Following this, there is a sequence of bytes called the payload. At the end of the container, there are one or more optional footers. A container must either have at least a single header or at least a single footer.
}
{% Rationale
Considering table \ref{tab:DFcompareMult} and \ref{tab:DFcompareMeta}, every container in every format has at least one header or one footer, including nested containers. Only ID3v23 as sole exception has a second, so-called extended header. Thus we have to support multiple headers and footers, even though this might be a singular case. But future formats might come to bring multiple headers, too. Modelling the middle part of a container as payload explicitly instead of just as list of sub-containers or fields makes sense because it allows to lazily read substructures, or entirely skip the payload.
}
{% Disadvantages
No disadvantages known
}
%%%% <-- DD %%%%

We saw that containers have a structure, and containers can live within other containers. But on the lowest level, there are leaf nodes, the fields:

%%%% DD --> %%%%
\DD{dd:502}
{% Title
Fields as the atomic unit of all byte sequences
}
{% Short description
\textbf{Field}s are the leaf nodes of the container metamodel: A field is a sequence of 1 to N consecutive bytes. A field has a \textbf{binary value} as well as an \textbf{interpreted value}, i.e. a human-understandable value with a specific meaning. We say that a field has a specific type, which basically describes the mapping between binary and interpreted value as well as the allowed values or format of a field.
}
{% Rationale
The term ``field'' is quite commonly used in binary data formats. It does not make sense to go down to individual byte or bit level. The smalles level of semantic in every binary or textual format is a field.
}
{% Disadvantages
No disadvantages known
}
%%%% <-- DD %%%%

Now towards headers and footers: Are they inherently different or basically the same? Fixed or variable size?

%%%% DD --> %%%%
\DD{dd:503}
{% Title
Headers and footers as sequences of fields are structurally identical
}
{% Short description
Headers and footers are sequences of fields, i.e. they must not nest a container. They are either variable or fixed-size. For both header and footer, the same model class called FieldSequence is used.
}
{% Rationale
No data format specifies a header or footer nesting a container-like data structure, they all consist of plain fields. Despite the location (before or behind the payload), there is nothing really distinguishing headers or footers from a structural perspective. Thus the same model class can be used for both. However, there is no english term for that class that seems to clearly be a grouping term for headers and footers.
}
{% Disadvantages
No disadvantages known
}
%%%% <-- DD %%%%

So far, we just introduced containers, fields, headers, footers and payload. We learned that containers might embed other containers, while headers and footers must only consist of fields. But what about the structure of the payload of a container? Of course, if the headers and footers cannot embed child containers, they must hide within the payload. Is this the only possibility? Of course not:
%%%% DD --> %%%%
\DD{dd:504}
{% Title
Payload either solely consists of containers or fields
}
{% Short description
The payload of a container either fully consists of a sequence of child containers or of a sequence of fields, but never both.
}
{% Rationale
Ultimately, we must boil payload down of fields, or put otherwise: We cannot recurse indefinitely into sub-containers. So at last, there must be a final sequence of child containers having payloads solely consisting of fields. So it is clear that we have both cases. But what about the mixed case: Should we have containers in the model that have both child fields neighbouring child containers? In rare cases such as - again - ID3v2, it would be possible to think of having the frames as child containers of the tag, followed by the padding child field of the tag behind it. However, we avoid such complexities, but payload is either ContainerBasedPayload or FieldBasedPayload. See next design decision of how we handle the ID3v2 special case.
}
{% Disadvantages
No disadvantages known
}
%%%% <-- DD %%%%

How to handle padding? If we look at the data format comparisons in \ref{tab:DFcompareMult} and \ref{tab:DFcompareMeta}, we see that padding is just a special case in ID3v2 and MP3. All other formats solve it ``more naturally'' by embedding it in special child container. ID3v2 just adds some nullbytes at the end of the tag payload behind the frames. How to model this? There are basically three possibilities:
\begin{itemize}
\item The padding is a part of the payload, basically a field. This seems most intuitive, but is already excluded by the previous design decision, because then we would need to support mixed payloads, consisting both of child containers and fields.
\item The padding is part of the payload, but considered as a very special child container.
\item The padding is an optional part of the tag footer.
\end{itemize}

Based on these alternatives, we can really only decide the following:
%%%% DD --> %%%%
\DD{dd:505}
{% Title
Padding in ID3v2 is modeled as very special child container of the tag
}
{% Short description
Padding in ID3v2 is modeled as very special child container of the tag, where the header is the first null byte, and all follow-up bytes form the payload. 
}
{% Rationale
Modeling it as child field of the payload is not possible as it would contradict \DesLink{dd:504}. Modeling as part of the footer would be odd, as not every version of ID3v2 defines a footer at all, and we would have a variable sized footer optionally starting with an arbitrary number of nullbytes, which would not be very intuitive from a library users perspective, too.
}
{% Disadvantages
The only disadvantage possibly to be identified that there could be padding just consisting of a single byte. This would mean we'd have a container with just a header, but an empty payload, which actually is quite degenerate.
}
%%%% <-- DD %%%%

The overall term for containers, headers, footers, fields and payload is a \textbf{datablock}. This term is used further on throughout this document.

There is another ID3v2 specific that we directly want to exclude here:
%%%% DD --> %%%%
\DD{dd:505b}
{% Title
ID3v2 transformations such as unsynchronization, compression, encryption are not handled generically
}
{% Short description
ID3v2 is clearly overdesigned. It includes an outdated mechanism called \emph{unsynchronization} to ensure players do not interpret ID3v2 tags as MP3 frames and try to play them. ID3v2 also defines frame-based compression and encryption possibilities.

These facilities are not handled generically in \LibName{}, they are just specifically implemented in the ID3v2 extensions.
}
{% Rationale
Unsynchronization is not needed anymore, as current players all know about ID3v2 tags. Even if it would be needed: There is no other data format know to date that defines any such transformation schemes, not even for compression or encryption.

Thus, declaring this all as generic concept is useless as only one format defines such things, and these things are even only very rarely used.
}
{% Disadvantes
No disadvantages known
}
%%%% <-- DD %%%%

% =======================================================================================================
\subsection{Representing a Data Format}%
\label{sec:RepresentingaDataFormat}%

Data Formats need some kind of representation:
%%%% DD --> %%%%
\DD{dd:506}
{% Title
Class for data formats and especially for container formats
}
{% Short description
There is a base class called \texttt{AbstractDataFormat} representing a general data format, which has a subclass called \texttt{ContainerDataFormat} that is used for all data formats listed in \SectionLink{sec:FormatComparison}. Each individual format is represented as an instance of \texttt{ContainerDataFormat}. These two classes are neither enums nor ``dynamic enums'', but just plain old java classes.
}
{% Rationale
We need some way to identify which data format a container belongs to. A class allows to store additional format-wide properties for logging or even with a functional notion behind. Why not using an enum to identify each supported data format? Because enums are static, and we do not want to change the enum whenever a new format comes around. And it is not clear which formats are out there by 3rd party. A dynamic enum pattern is unnecessarily complexity here, so just a plain class. Why a just an instance of \texttt{ContainerDataFormat} rather than a new subclass for each format supported? First of all, data formats must be used as tokens by end-users of the library to refer to which tags or containers they want  to read. Creating a new sub-class instance everytime they want to have a token is strange. Instead, they can use a public constant instance as token. The next question: Why at all a \texttt{ContainerDataFormat} subclass? The reason is that \LibName{} might want to support even more different formats in future, e.g. XML. This can be a sibling subclass of \texttt{AbstractDataFormat}. From now on, everything described in this section is only covering container data formats.
}
{% Disadvantes
No disadvantages known
}
%%%% <-- DD %%%%

But that's not all of it. If we structure data belonging to a format into containers, headers, footers and so on according to the generic metamodel, \emph{how exactly} is a correct datablock of a given format structured? Of course, each format individually specifies the exact structure of its containers (how many headers, footers etc., what the payload can contain), headers (which fields make up a header), fields (which type a field has, how long it is and which values it can have) and so on. Thus, we need a place where we describe the structure of all datablocks belonging to a data format in more detail, otherwise we could not parse this data generically.

We define:
%%%% DD --> %%%%
\DD{dd:507}
{% Title
\texttt{DataFormatSpecification} provides \texttt{DataBlockDescription}s, \texttt{DataFormatRepository} maintains all \texttt{DataFormatSpecification}s
}
{% Short description
The exact properties of a datablock is described by an instance of the class \texttt{DataBlockDescription}. Which properties are needed in detail is determined later in \SectionLink{sec:DatablockProperties}.
The interface \texttt{DataFormatSpecification} provides access to all \texttt{DataBlockDescription}s offered by one specific data format. Last but not least there is a \texttt{DataFormatRepository} interface which basically only maintains a list of all supported data formats and their corresponding \texttt{DataFormatSpecification}s.

A concrete \texttt{DataFormatSpecification} is defined in an extension and loaded when starting \LibName{}. 
}
{% Rationale
For generically parsing data blocks according to a format definition, the parser code needs information about the exact structure of a data block. Thus, we need a place to maintain all data formats, their specifications and a description of each possible individual container, field etc.
}
{% Disadvantes
No disadvantages known
}
%%%% <-- DD %%%%

% =======================================================================================================
\subsection{\texttt{DataBlockDescription} Common Properties}%
\label{sec:DatablockProperties}%

First of all, we need a clear way to identify each specific datablock that might occur in the data format. Every container type, header, footer, field and payload needs an identifier:
%%%% DD --> %%%%
\DD{dd:508}
{% Title
Each datablock of a format has a specification id unique across all supported formats
}
{% Short description
Each distinctly defined container, header, footer, field or payload block of a data format is assigned a unique specification id. Using this specification id, a parser implementation can lookup the \texttt{DataBlockDescription} of the block from its associated \texttt{DataFormatSpecification}. Specification ids are human-readble rather than generated GUIDs. The uniqueness is guaranteed by using a top-level prefix identifier that is directly checked to be unique upon all loaded data formats when loading the extension defining the data format. The ids reflect the hierarchical nature of a data format according to the container meta model, following these rules:
\begin{itemize}
\item Each id consists of one or more \emph{segments} separated by a dot.
\item A segment name does only contain ASCII alphanumeric characters, starting always with a lower-case letter and preferring lower-case only letters, i.e. no special characters, no blanks etc. So a datablock id has much in common with a Java package name. 
\item The first segment is the data format top-level prefix which equals the (single) top-level container id of the data format. So we have the implicit decision that each format starts off with a single container on top-level enclosing everything else. This is true for all data formats considered here.
\item Each container consists of an arbitrary number of headers and footers as well as exactly one payload. The segment name of a container payload is always \texttt{payload}. If there is just a single header or footer, it is called header or footer respectively. Multiple headers or footers bear more specific, distinct names.
\item Child fields of a header or footer have descriptive names and so on 
\end{itemize}
}
{% Rationale
When parsing, the format structure of a datablock must be clearly visible and available. By an id, this format structure is clearly adressable and the corresponding \texttt{DataBlockDescription} can be obtained from a \texttt{DataFormatSpecification}. The uniquenss of the id guarantees that the parsing logic cannot unintentially try to parse a block of bytes according to the incorrect format.

The reason for not using generated unique ids such as counters or GUIDs is that we want to have memorable and recognizable names, both for library developers (e.g. during debugging) or \LibName{} end-users that need to work with datablock ids directly. 
}
{% Disadvantes
No disadvantages known
}
%%%% <-- DD %%%%

Besides their id, what else might be desirable on first glance when looking at a datablock taken from a data format's specification? Some descriptive stuff comes to mind. Second, it seems like every datablock must have exactly one type that is useful to store. So we can state:
%%%% DD --> %%%%
\DD{dd:509}
{% Title
Basic properties held in a \texttt{DataBlockDescription}
}
{% Short description
Each \texttt{DataBlockDescription} instance holds the datablock id of the datablock according to \DesLink{dd:508}. In addition, it has:
\begin{itemize}
\item A more human-readable name of the datablock, if available; only for display or documentation purposes
\item A description of the datablock, probably taken from the format specification, preferably in English. This is meant to give more information about the purpose of the datablock, but has no other meaning.
\item The \texttt{DataBlockType} of the datablock, which is: \texttt{HEADER}, \texttt{FOOTER}, \texttt{CONTAINER}, \texttt{FIELD}, as well as \-- according to \DesLink{dd:504} \-- \texttt{FIELD\_BASED\_PAYLOAD} or \texttt{CONTAINER\_BASED\_PAYLOAD}.
\end{itemize}
}
{% Rationale
These properties are clear from the beginning, the concrete is known statically, and it is needed to take decisions during generic parsing. 
}
{% Disadvantes
No disadvantages known
}
%%%% <-- DD %%%%
 
We defined that datablock ids are organized hierarchically as their real blocks are organized hierarchically. However, still, it is not sufficient to somehow maintain the ``hierarchy'' indicated by the metamodel only in the datablock ids. Instead, we define:
%%%% DD --> %%%%
\DD{dd:510}
{% Title
\texttt{DataBlockDescription}s contain a list of all child ids they might contain, where order matters
}
{% Short description
A \texttt{DataBlockDescription} instance contains a list of all child datablock ids that form the structure of the datablock described. While headers, footers, containers and payload usually has child ids, \texttt{DataBlockDescription}s of fields must not define child datablock ids. The list of child ids is ordered with the following meaning:
\begin{itemize}
\item For containers, the child id list exactly matches the correct order of headers, payload and footers that build the container
\item For headers, footers and field-based payload, the child id list exactly matches the order of child fields within the header, footer or field-based
\item For container-based payloads, the child id list order does not have a meaning, i.e. if multiple different container types are allowed, they might appear in any order 
\end{itemize}
}
{% Rationale
The parsing code somehow needs information about what child blocks of which format to expect within a given datablock, otherwise parsing it correctly is simply impossible. Each data format clearly defines the order of fields, headers and footers. Usually, most container formats define just exactly one child container that can appear in a container-based payload. However, there are cases such as QuickTime (atom vs. QT atom container) that define multiple different container types that might appear in any possible order. 
}
{% Disadvantes
No disadvantages known
}
%%%% <-- DD %%%%

We first have to define some limitations for these datablock ids that should be made clear:
%%%% DD --> %%%%
\DD{dd:511}
{% Title
Datablock ids and their segments MUST not be used for any logic 
}
{% Short description
Especially, no assumptions about the hierarchical relations of distinct blocks must be done based on their id. E.g. a block with specification id \texttt{id3v23.payload.talb.encoding} not necessarily is a child of a block with id \texttt{id3v23.payload.talb}, as there could be multiple \texttt{talb} containers within an ID3v23 tag. So datablock ids are only specification ids, not instance ids! Even within the same specification, a case might occur where the same chunk of data with the exact structure appears in several places, e.g. as child of the top-level container, and also as deeper nested child. Moreover, some container formats encourage to embed datablocks belonging to even completely different data formats. How do we handle such cases? In no special way. Even if a container might appear on several levels, we just define its structure once in the data format with just one id. And if a datablock of a data format is embedded in another container of a different format, it still keeps its well-defined datablock id according to its data format. So this again shows that based on the id, we can never determine the real hierarchy level or instance relations of two datablocks during parsing! 
}
{% Rationale
Quite clear, otherwise we would implement a lot of bullshit code
}
{% Disadvantes
No disadvantages known
}
%%%% <-- DD %%%%

% =======================================================================================================
\subsection{Generic and Concrete Containers}%
\label{sec:ConcreteandGenericContainers}%

Data formats define different kinds of \emph{container types}. A container type for us is defined as a data structure having a fixed number of headers and footers, where each header and footer has a strictly defined sequence of fields with strictly defined syntax and semantics, yet leaving undefined how the payload looks like. They just state that there is a payload consisting of bytes, but not how it is structured. Most often, there is just one header or just one footer. Here are some examples of container types:
\begin{itemize}
\item Most container formats such as RIFF or Matroska define exactly one container type. In these formats, those containers usually can be found on top-level as well as arbitrarily nested within parent containers   
\item Some formats that are no container formats in the narrower sense\footnote{In terms of their main purpose is to contain \emph{arbitrary} multimedia data, not only data of a specific kind.} such as ID3v23 use a slightly different container type for the top-level (the tag) container as for the child (the frame) containers 
\item Some container formats such as QuickTime even define multiple container types that can appear on the same level: First of all, there are the top-level containers called atoms; one extension of atoms are QT atoms, which just use a slightly extended header compared to the usual atoms. Both might appear on top-level. Furthermore, as child container types, not only atoms or QT atoms might appear, but also QT atom containers (a slightly confusing term here, but this is how QuickTime names them)
\end{itemize}

Container types are the pillars of the most basic property of most well-designed container formats: They define the structures of their basic buildings blocks (i.e. their container types) just once, and specialize this basic structure whenever needed. This at first allows to write generic parsers that may skip containers whose semantics and purpose they might not be aware of, but yet they still know their structure and thus are able to determine where the next container actually starts. This allows to extend data formats by new subtypes whereas existing parsers still work.

But this is not yet enough. Most container formats go much farther than only define a generic container type that can be parsed and defines a structure. They specialize in terms of defining specific containers having a specific meaning (data content) and whose payload follows a deeper defined format. These specialized containers can be said to have the same structure as a given container type, but they fill this container type with meaning and the payload with additional structure.

We define:
%%%% DD --> %%%%
\DD{dd:512}
{% Title
\COMPdataFormatManagement{} distinguishes generic and concrete containers
}
{% Short description
\COMPdataFormatManagement{} distinguishes generic and concrete containers:
\begin{itemize}
\item A container is called a \textbf{generic container} if it is just known to follow a container type's structure, but a more specialized container type is not (yet) known; more technically speaking: A generic container is a container whose detailed payload structure is not yet known in advance, but can only be determined at runtime, usually by reading some specific \texttt{id} field of the container's header or footer. Examples for generic containers are: Generic ID3v23 frame, generic (QT) atom, generic Matroska segment, generic APEv2 item and others. We can say that generic containers form the archetypes for the even more useful concrete containers. \COMPdataFormatManagement{} must maintain \texttt{DataBlockDescription}s for generic containers.
\item A \textbf{concrete container} is a container with a well-defined payload structure. It might be based on a generic container which means it entirely inherits its header and footer structure, while it might ``override'' specific field values in headers and footers. Examples for concrete containers are: ID3v23 tag (because its payload structure is already statically clearly defined), ID3v23 TALB frame, ID3v23 GEOB frame, moov QT atom, APEv2 title item and others. \COMPdataFormatManagement{} must maintain \texttt{DataBlockDescription}s for concrete containers. 
\end{itemize}

Of course, there are much more concrete containers than there are generic containers.
}
{% Rationale
Generic containers are necessary such that \LibName{} can basically parse data format content, yet not necessarily understanding its payload. These ``unknown'' containers can safely be skipped, and \LibName{} can later be extended to also understand these concrete types.

Concrete containers are necessary such that \LibName{} can read and write data with specific semantics and inner structure. Otherwise it would not be possible to write album, track, artist etc. fields to metadata container formats and so on.
}
{% Disadvantes
No disadvantages known
}
%%%% <-- DD %%%%

How exactly are these generic and concrete container \texttt{DataBlockDescription}s defined in a \texttt{DataFormatSpecification} and used at runtime?

%%%% DD --> %%%%
\DD{dd:513}
{% Title
\texttt{DataFormatSpecification}s list generic container as children, parsers resolve them to concrete containers at runtime
}
{% Short description
Generic container types might occur on arbitrary levels of the data block hierarchy, either on top-level or as child datablocks of a \texttt{CONTAINER\_BASED\_PAYLOAD} datablock. The semantics is: The file/media stream or payload contains a sequence of containers having a specific basic structure (i.e. they have a specific container type). This type can be found to be even more specific at runtime. For this, container formats define a special id field either in the container header or footer. This id field identifies the concrete type of container. After the parser has read the id field, it can lookup if there is a more specific \texttt{DataBlockDescription} for this id defined in its \texttt{DataFormatSpecification}. If so, the generic container is changed to the concrete container, thus the payload can now be parsed differently. 
}
{% Rationale
All container formats define their \texttt{CONTAINER\_BASED\_PAYLOAD} to contain a multitude of different concrete containers that all follow (usually) a single generic container type.
}
{% Disadvantes
No disadvantages known
}
%%%% <-- DD %%%%

The actual detailed parsing process is described within the design of \COMPdataPartManagement{}.

Now we already mentioned in \DesLink{dd:513} that there is ``usually'' only a single generic container defined within a \texttt{CONTAINER\_BASED\_PAYLOAD}. However, there are also already two exceptions we can list here:
\begin{itemize}
\item A (QT) atom generic container having a \texttt{CONTAINER\_BASED\_PAYLOAD} could have two different generic container types as child containers: Either (QT) atoms again, or QT atom containers that have a totally different header. 
\item We already ``artificially'' introduced a second case with \DesLink{dd:505}: An ID3v23 tag \texttt{CONTAINER\_BASED\_PAYLOAD} either contains a generic ID3v23 frame or a padding container.
\end{itemize}

If a \texttt{CONTAINER\_BASED\_PAYLOAD} might contain different types of containers in arbitrary order, how is a parser able to tell which generic container type he is handling currently? This is all based on magic keys and described in \SectionLink{sec:MagicKeys}.

% =======================================================================================================
\subsection{Inheriting and Overriding Datablock Structures}%
\label{sec:InheritingandOverridingDatablockStructures}%

TODO

% =======================================================================================================
\subsection{Magic Keys}%
\label{sec:MagicKeys}%

A magic key is a fundamental concept of most data formats: It allows to identify a block of bytes as belonging to a data format, enabling generic parsers to understand how to parse a byte sequence. Thus, it is usually located at the start of file. For example, an Ogg page is identified by the magic key string ``OggS'', encoded as ASCII. Of course, this somewhat implies that different data formats use different keys.

Translated to this document, here are the main properties of magic keys:
\begin{itemize}
\item A magic key has a single fixed byte identification sequence that is usually an ASCII encoded string
\item It is either starting at the beginning of a container, or at a well-defined fixed offset from the start of the container, thereby being a field in the container's header or footer
\item That said, also footers have magic keys, e.g. for ID3v23, APEv2 or Lyrics3v2
\item Data formats might have multiple magic keys identifying them - one example is RIFF where the magic key even identifies the byte order of the container
\end{itemize}

We summarize:
%%%% DD --> %%%%
\DD{dd:520}
{% Title
A top-level container defines one or several magic keys 
}
{% Short description
Every top-level container must define one or multiple magic keys identifying the container and data format. The magic key is either at the start (header) or at the end (footer) of a container. We introduce a class for describing the properties of a magic key. It defines:
\begin{itemize}
\item The magic key bytes plus its string representation
\item Optional: A fixed byte-length distance from start of header or footer
\item Whether the magic key is usable for backward reading or not
\item A bit length of the magic key
\end{itemize}
}
{% Rationale
Every top-level container must at least have one magic key, because otherwise we cannot identify it. The possibility of multiple different magic keys is implied by e.g. RIFF. ID3v24 defines a header magic key as well as a different footer magic key for backward reading. Some data formats require or at least benefit from ``backward reading'' which means to scan for e.g. tags at the end of a file. For this purpose, formats such as ID3v24, APEv2 and Lyrics3v2 define footers with specific magic keys. Thus, we need a byte-length distance to specify where the magic key starts exactly. The bit length in contrast to a byte length is necessary for the MP3 magic key which is not a multiple of 8 bits, but 11 bits long.  
}
{% Disadvantes
No disadvantages known
}
%%%% <-- DD %%%%

What about nested containers? Do they also need to have magic keys? First of all, we have generic containers whose exact structure is only revealed at runtime during parsing. Having an id that is always different, they usually do not qualify to contain magic keys. However, we already defined that ID3v23 padding is treated as nested container. Likewise, we have QT atom containers that can reside next to sibiling QT atoms (which are generic), but are structured entirely different. If we parse the payload of a top-level container, how can the parser know if it has a QT atom or a QT atom container for QuickTime, and for ID3v23, how can the parser know if it is a usual ID3v2 frame or already padding? This can be done by using magic keys:

%%%% DD --> %%%%
\DD{dd:521}
{% Title
Nested containers define magic keys if not generic
}
{% Short description
All concrete child containers must define a magic key, while generic containers could but usually do not define magic keys. If a specific payload type is allowed to contain different generic container types - such as QuickTime with atoms and QT atoms - these container types must be structurally very similar such that during parsing, it is clear depending on the id which generic container type it is exactly. 
}
{% Rationale
With a magic key, a parser can directly either identify a child as concrete container, or - if no identification was possible - as a generic container. In case of QuickTime, QT atoms just define additional fields in the header compared to simple atoms. Depending on the id of the atom, it is clear if it is a QT atom or a usual atom. By changing its runtime type, a parser can deal with it the same way as with all generic containers.
}
{% Disadvantes
No disadvantages known
}
%%%% <-- DD %%%%

Now the question arises how to identify if a byte sequence rather belongs to a generic container or to a container with a magic key. We could iterate all magic keys of all known containers. If a magic key is matching, we have the corresponding container. If it is not, we have the sole generic container before us. This would work quite well. However, there is a very special case for Lyrics3v2: This tag does not define a tag size, thus the payload size is not known in advance. Only if the magic key of the footer is found after a frame, we know that the payload parsing is finished. For the case of generic containers as well as the case of Lyrics3v2 - or more generally - containers not defining a size, we can also use a special form of magic keys:

%%%% DD --> %%%%
\DD{dd:522}
{% Title
Magic keys are also used to indicate absence of a generic container
}
{% Short description
A special kind of magic key is used to indicate absence of a generic container type: If the parser finds the defined byte sequence of this magic key, it knows that the follow-up bytes \emph{do not} belong to the generic container type tried to identify. And: If the parser \emph{does not} find the magic key bytes, it assumes the generic container is present. So this kind of magic key is serving the exact opposite of the usual purpose of a magic key: It indicates the absence of a container instead of its presence.
}
{% Rationale
An ``absence'' magic key can solve two problems: If we do not find the absence magic key, we can assume that the follow-up bytes belong to the current generic container type tried to identify. Otherwise, if we find the bytes of an absence magic key, this is prooving that the follow-up bytes do not belong to the current generic container type tried to identify. Second, this can be used for Lyrics3v2: By using the magic key of the Lyrics3v2 footer as absence magic key for the generic Lyrics3v2 frame container, the parser knows when it is finished parsing the payload.
}
{% Disadvantes
No disadvantages known
}
%%%% <-- DD %%%%

How to realize these things? We can think of a class hierarchy:
%%%% DD --> %%%%
\DD{dd:523}
{% Title
\texttt{AbstractMagicKey} as base class, with subclasses \texttt{GenericContainerPresentMagicKey} and \texttt{ConcreteContainerPresentMagicKey}
}
{% Short description
All commonalities of both kinds of magic keys are bundled in a base class. All magic keys indicating a concrete container when a magic key is present are of concrete class \texttt{PresenceMagicKey}, and those indicating absence of a concrete and presence of a generic onctainer when a magic key is \emph{not} found are of concrete class \texttt{AbsenceMagicKey}.
}
{% Rationale
This clearly communicates intent in contrast to just using slightly different constructors. Furthermore it allows to handle this subtle semantic opposite situation within the code of these classes themselves instead of slipping into the parser code where everybody is wondering what the heck it means. Javadocs on the concrete classes can clearly say what the purpose of these classes is and when they are used.
}
{% Disadvantes
No disadvantages known
}
%%%% <-- DD %%%%


% =======================================================================================================
\subsection{Header and Footer Properties}%
\label{sec:HeaderProperties}%


% =======================================================================================================
\subsection{Container Properties}%
\label{sec:ContainerProperties}%


% =======================================================================================================
\subsection{Payload Properties}%
\label{sec:PayloadProperties}%


% =======================================================================================================
\subsection{Field Properties}%
\label{sec:FieldProperties}%













%###############################################################################################
%###############################################################################################
%
%		File end
%
%###############################################################################################
%###############################################################################################