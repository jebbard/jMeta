%===============================================================================================
%		General Design Decisions
%===============================================================================================

\chapter{Allgemeine Designentscheidungen}
\label{sec:GeneralDesignDecisions}

In diesem Kapitel werden allgemeine Designentscheidungen getroffen, die einen unumkehrbaren Einfluss auf die Architektur der Gesamt-Library haben. Sie definieren die Rahmenbedingungen für die Library, und dienen als Basis zur Definition ihrer technischen und vorallem fachlichen Architektur. Sie bilden auch generell und übergreifend die Basis zur Erfüllung der Anforderungen, haben daher noch keinen Bezug zu einer spezifischen Anforderung.

Die Erfüllung der spezifischen Anforderungen wird durch die detaillierten Designentscheidungen ermöglicht, die im Kapitel \SectionLink{sec:FunctionalArchitectureChap} und im Teil \SectionLink{sec:Design} definiert sind.

%-----------------------------------------------------------------------------------------------
%		Design Decision: Java SE 8
%-----------------------------------------------------------------------------------------------

\section{Verwendung von Java}
\label{sec:VerwendungVonJava}

\DD{dd:001}
{% Titel
	\LibName{} basiert auf Java SE 8%
}
{% Kurzbeschreibung
	\LibName{} wird basierend auf dem ``latest update'' von Java SE 8 entwickelt. Ein Umstieg auf neuere Java-Versionen wird im Rahmen des Lebenszyklus der Library wiederholt in Erwägung gezogen.
}
{% Begründung
Java als Programmiersprache ist etabliert und weit verbreitet sowie plattformunabhängig. Prinzipiell ist der Portierungsaufwand zu anderen  Betriebssystemen, Java ME sowie Java für Smartphones (z.B. Android) damit weitaus geringer als bei Verwendung von beispielsweise C/C++. Da der Autor langjährige Erfahrung mit Java hat, stellt deren Verwendung eine höchstmögliche Produktivität sicher. Die Konkurrenzlibraries im Java-Umfeld sind überschaubar. Die aktuell (Stand 15. März 2016) neueste Version Java 8 wird ganz klar deshalb genutzt, weil die neuesten verfügbaren Features von Sprache und Library genutzt werden sollen. Java 7 hingegen wird ab voraussichtlich April 2015 von Oracle nicht mehr mit öffentlichen Updates versorft, Support ist aber weiterhin einkaufbar. Somit kann es sein, dass öffentliche Fixes für bekannte Bugs nicht mehr für Java 7 erscheinen werden.
}
{% Nachteile
Anwendungen, die auf Java 7 oder älter basieren, werden von \LibName{} nicht mehr unterstützt. Das träfe dann insbesondere auf Java-EE-Anwendungen zu, die vielfach noch auf so innovative Produkte wie Websphere 8.0 (oder älter!) aufsetzen.
}

%-----------------------------------------------------------------------------------------------
%		Design Decision: keine Dritt-Libraries
%-----------------------------------------------------------------------------------------------

\section{Verwendung anderer Libraries}
\label{sec:VerwendungAndLib}

\DD{dd:002}
{% Titel
	\LibName{} setzt so wenig wie möglich Dritt-Libraries ein
}
{% Kurzbeschreibung
	\LibName{} setzt weitestgehend allein auf die Libraries von Java SE auf. Es werden - im produktiven Code - keine Abhängigkeiten zu dritten Libraries genutzt.
}
{% Begründung
Zusätzliche Abhängigkeiten können zu Mehraufwänden bei der Verwaltung (Build, Deployment, Versionsmanagement) führen. Letztlich ist \LibName{} dann auch von der Lizenzierung, vom Release- und Bug-Management und den ``Launen'' der Library-Entwickler abhängig, was hiermit vermieden wird. Zudem wird die Anwendung insgesamt leichtgewichtiger, sowohl zur Laufzeit als auch im Hinblick auf die Auslieferungsgröße.
}
{% Nachteile
Evtl. höherer Entwicklungsaufwand, weil das Rad ab und an ``neu erfunden'' wird.
}

%-----------------------------------------------------------------------------------------------
%		Design Decision: komponentenbasiert
%-----------------------------------------------------------------------------------------------

\section{Komponentenbasierte Library}
\label{sec:KomponentenbasierteLibrary}

\DD{dd:003}
{% Titel
	\LibName{} ist komponentenbasiert
}
{% Kurzbeschreibung
	\LibName{} besteht aus sogenannten Komponenten (Definition siehe nächsten Abschnitt), die sich gegenseitig nur über klar definierte Schnittstellen verwenden.
}
{% Begründung
Die Untergliederung in Komponenten ermöglicht es, die Komplexität der Library über ihren gesamten Lebenszyklus hinweg besser zu beherrschen. Durch eine sinnvolle Komponentengliederung wird eine klare Aufgabentrennung, Entkopplung und eine bessere Erweiterbarkeit sichergestellt. Änderungen an einer Implementierung einer Komponente haben ein deutlich geringeres Risiko, sich auf weite Teile der Library auszuwirken, sondern werden lokal auf die Komponentenimplementierung beschränkt bleiben.
}
{% Nachteile
Ggf. etwas mehr overhead und mehr Komplexität, da Mechanismen zur Entkopplung eingesetzt werden müssen.
}

%-----------------------------------------------------------------------------------------------

\subsection{Definition des Komponentenbegriffs}
\label{sec:ComponentTermDefinition}

Eine \emph{Komponente} in \LibName{} ist \emph{eine abgeschlossene Software-Einheit mit klar definierter Aufgabe}. Sie bietet \emph{Services} an, die über eine klar \emph{definierte Schnittstelle} genutzt werden können. Diese Services werden sowohl von den Anwendern der Library als auch von anderen Komponenten der Library genutzt. Eine Komponente hat ggf. \emph{Datenhoheit} über bestimmte Daten, d.h. nur die Komponente selbst darf diese Daten lesen und modifizieren. Andere Komponenten müssen diese spezielle Komponente nutzen, um diese Daten zu verwenden. 

Die folgende Abbildung zeigt schmeatisch eine \LibName{} Komponente:

\begin{figure}[H]
	\centering
	\includegraphics[width=1.00\textwidth]{Figures/Part_II/II_2_ComponentStructure.pdf}
	\caption{Struktur einer Komponente}
	\label{fig:5_3_SCH_Komponente}
\end{figure}

Die Komponentenschnittstelle besteht aus einem oder mehreren Java interfaces, exceptions und Datentypen.
\begin{itemize}
	\item \emph{Java interfaces} stellen die funktionalen API der Komponente dar, jede Methode entspricht einem Service der Komponente. Ein Java interface wird für eine klar definierte Unteraufgabe der Komponente genutzt. Manche Interfaces haben Erzeugungscharakter, geben also Zugriff auf andere Interfaces der Komponente.
	\item \emph{Datentypen} sind konstante Java-Klassen, die direkt in implementierungsform zur Verfügung gestellt werden. Meist dienen sie dazu, Daten zu halten, die als Eingabe oder Rückgabe verwendet werden.
	\item \emph{Exceptions} sind Fehler die auf funktionelle Fehler hindeuten. Es handelt sich um geprüfte Exceptions, die an der Service-Schnittstelle definiert werden und vom Anwender behandelt werden müssen.
\end{itemize}

%-----------------------------------------------------------------------------------------------
%		Design Decision: Keine Schichtenarchitektur in Komponenten
%-----------------------------------------------------------------------------------------------

\subsection{Designentscheidungen zur Verwendung von Komponenten}
\label{sec:DesVerwKomp}

%-----------------------------------------------------------------------------------------------
%		Design Decision: Entkoppeln von Komponenten über ein leichtgewichtiges Service-Locator-Pattern
%-----------------------------------------------------------------------------------------------
\DD{dd:004}
{% Titel
	Entkoppeln von Komponenten über ein leichtgewichtiges Service-Locator-Pattern
}
{% Kurzbeschreibung
	Um geringe Kopplung zwischen den Komponenten zu erreichen, dürfen sich diese nur über ihre Komponentenschnittstellen kennen. Dies trifft auch für das Erzeugen anderer Komponenten bzw. das Erlangen einer Referenz auf ein anderes Komponenteninterface zu. Um dies zu erreichen, wird ein leichtgewichtiges Service-Locator-Pattern in Form einer eigenen Utility verwendet.
}
{% Begründung
Wir wollen vernünftige Entkopplung zwischen Komponenten, und daher brauchen wir eine entsprechende Utility. Diese soll leichtgewichtig sein, damit scheiden Java EE und Spring aus, Drittlibraries wie Google Guice ebenso wegen \DesLink{dd:002}.
}
{% Nachteile
 Keine erkennbar
}

%-----------------------------------------------------------------------------------------------
%		Singleton Components
%-----------------------------------------------------------------------------------------------

\DD{dd:005}
{% Titel
	Singleton-Komponenten
}
{% Kurzbeschreibung
	Jede Komponente hat eine einzelnes \emph{Zugriffs-Java-interface}, das wiederum Zugriff auf all Services der Komponente gewährt. Dazu kann das Zugriffsinterface Instanzen vefschiedener anderer Klassen oder Interfaces zurückliefern, mit denen der Aufrufer dann arbeiten kann.

Aus einer Laufzeit- und Implementierungsperspetive hat jedes der Zugriffs-Java-Interfaces eine Art ``singleton''-Implementierung. Es darf also nur eine Instanz der Zugriffs-Java-Interfaces einer Komponente geben. Natürlich darf es im Kontrast dazu mehrere Instanzen jedes anderen Interfaces geben, dass die Komponente definiert.
}
{% Begründung
Die Zugriffs-Java-Interfaces sind nur funktional, und da es nur genau eine Komponentenimplementierung in \LibName{} je Komponente gibt, hat man immer nur eine implementierende Klasse. Für diese ist zur Laufzeit nur eine Instanz erforderlich, da sie keine Zustände hält. Dies spart Speicherplatz und Initialisierungsaufwand.
}
{% Nachteile
 Keine erkennbar
}

%-----------------------------------------------------------------------------------------------
%		Design Decision: Entkoppeln von Komponenten über ein leichtgewichtiges Service-Locator-Pattern
%-----------------------------------------------------------------------------------------------

\DD{dd:006}
{% Titel
	Unterteilung in Subsysteme
}
{% Kurzbeschreibung
	Eine Ebene über den Komponenten untergliedern wir \LibName{} noch in sogenannten \emph{Subsysteme}. Ein Subsystem zerfällt in Komponenten, und hat sonst keine anderen Inhalte. Es ist also nur eine weitere Gliederungsebene. Generell ist es Komponenten innerhalb desselben Subsystems erlaubt, stärker an andere Komponenten gekoppelt zu sein, während Subsysteme untereinander eher über eine geringere Kopplung verfügen sollten. Um dies zu gewährleisten, können Subsysteme sogenannte Fassadenkomponenten anbieten.
}
{% Begründung
Anhand dieser Untergliederung können wir bereits eine grobe Architektursicht mit den wichtigsten Elementen und Abhängigkeiten definieren und auf dieser Basis die Library schrittweise weiter verfeinern.
}
{% Nachteile
 Keine erkennbar
}


%-----------------------------------------------------------------------------------------------
%		Design Decision: API and Implementation Layers
%-----------------------------------------------------------------------------------------------

\DD{dd:007}
{% Titel
	API- und Implementierungs-Layer
}
{% Kurzbeschreibung
	Jede Komponente bietet ihre Dienste, Exceptions und Datentypen über einen API-Layer an. Dieser stellt die öffentliche Schnittstelle der Komponente dar. Andere Komponenten ebenso wie der \LibName{}-Anwender dürfen die Komponente nur über diese API-Klassen verwenden. Der Implementierungs-Layer der Komponente implementiert den API-Layer und ist privat. Insbesondere sind compile-Zeit-Abhängigkeiten zu dessen Klassen von anderen Komponenten oder Anwender-Klassen aus verboten.
}
{% Begründung
  Es gibt eine Klare Trennung zwischen privaten und öffentlichen Anteilen, was die Kopplung und das Risiko von Fehlerpropagation sowie Inkompatibilitäten verringert, weil sich interne Änderungen an der Komponente idealerweise gar nicht auf nutzende Komponenten auswirken.
}
{% Nachteile
 Keine erkennbar
}

%-----------------------------------------------------------------------------------------------
%		Keine Schichtenarchitektur in der Komponenten-Implementierung
%-----------------------------------------------------------------------------------------------

\DD{dd:008}
{% Titel
	Keine Schichtenarchitektur in der Komponenten-Implementierung
}
{% Kurzbeschreibung
	Die Implementierungs-Schicht einer Komponente in \LibName{} wird nicht weiter in Unter-Schichten gegliedert (wie dies in EE-Anwendungen häufig der Fall ist). Die innere Struktur einer Komponente wird durch keine Architekturvorgaben standardisiert, sondern zweckdienlich implementiert. Eine Schichtenarchitektur wäre beispielsweise: Eine Schicht kümmert sich um das Prüfen von Vorbedingungen, eine zweite implemeniert die Funktionalität, eine dritte kümmert sich um den Zugriff auf externe Daten.
}
{% Begründung
Eine Schichtenarchitektur in der Komponentenimplementierung ist für \LibName{} nicht notwendig und verkompliziert dessen Architektur. Es handelt sich um keine klassische ``3-tier''-Anwendung, sondern eine Hilfslibrary, in welcher nur wenige Komponenten Datenzugriffe durchführen. Eine Schichtenarchitektur würde zu einer Verringerung der Übersichtlichkeit und mehr Redundanz führen, ohne nennenswerte Vorteile bei ``separation of concerns'' oder Entkopplung zu bringen.
}
{% Nachteile
 Keine erkennbar
}

%-----------------------------------------------------------------------------------------------
%		Design Decision: Entwicklungsumgebung
%-----------------------------------------------------------------------------------------------

\section{Entwicklungsumgebung}
\label{sec:entw}

\DD{dd:009}
{% Titel
	Entwicklungsumgebung
}
{% Kurzbeschreibung
	Als Entwicklungsumgebung wird eine Kombination aus Eclipse, Maven und Subversion genutzt.
}
{% Begründung
Bekannte und kostenloste Toolsuite.
}
{% Nachteile
 Keine erkennbar
}

%-----------------------------------------------------------------------------------------------
%		Design Decision: Multithreading
%-----------------------------------------------------------------------------------------------

\section{Multithreading}
\label{sec:mult}

\DD{dd:010}
{% Titel
	\LibName{} ist nicht thread-safe
}
{% Kurzbeschreibung
	\LibName{} ist keine thread-safe Library und verwendet keine Java-APIs, die thread-safe sind.
}
{% Begründung
Thread-Sicherheit bedeutet ggf. Performance-Verringerung durch Erzeugung von Synchronisationspunkten und Erhöhung der Gesamtkomplexität. Single-thread-Anwendungen werden benachteiligt. Es ist schwierig, thread-safety \emph{korrekt} umzusetzen. Anwender können selbst dafür Sorge tragen, dass ihre multi-threaded-Anwendung thread-safe ist.
}
{% Nachteile
Keine erkennbar
}

%-----------------------------------------------------------------------------------------------
%		Design Decision: Architektur
%-----------------------------------------------------------------------------------------------

\section{Architektur}
\label{sec:arch}

\DD{dd:011}
{% Titel
	Architektur von \LibName{}
}
{% Kurzbeschreibung
	\LibName{} basiert auf der technischen und fachlichen Architektur, wie sie in den Kapiteln \SectionLink{sec:TechnicalArchitectureChap} und \SectionLink{sec:FunctionalArchitectureChap} definiert wird.
}
{% Begründung
Siehe Diskussion der Architektur im Detail in den nächsten Abschnitten.
}
{% Nachteile
Siehe Diskussion der Architektur im Detail in den nächsten Abschnitten.
}

%###############################################################################################
%###############################################################################################
%
%		File end
%
%###############################################################################################
%###############################################################################################