%-----------------------------------------------------------------------------------------------
%		\COMPextensionManagement{} Design
%-----------------------------------------------------------------------------------------------

\section{\COMPextensionManagement{} Design}
\label{sec:COMPextensionManagementDesign}

This section describes the most important design decisions for the technical helper component \COMPextensionManagement{}. The main task of this component is discovery of extensions and to make their interfaces available to the whole library, preferably in a very generic way.

In the first version of this components, extensions were loaded by a relatively complex \texttt{URLClassLoader} approach and used a main and an extension-specific XML configuration file. However, this was more complex than necessary, thus we define here a more lightweight approach:
%%%% DD --> %%%%
\DD{dd:240}
{% Titel
Extensions are discovered and loaded at library startup directly from the class path, no dynamic loading of extensions is required
}
{% Kurzbeschreibung
When the library is first used in a Java application, it scans the class path for any available extensions. The extensions that are available at that time are available for further use. There is no possibility for the user itself to add extensions. Furthermore, it is not possible to add, exchange or update extensions at runtime in any way.
}
{% Begründung
It is quite convenient for users to simply put extension onto the class path, e.g. using Maven or Gradle, and it is auto-detected. This fulfills the requirement \SectionLink{sec:ANF007ErweiterbarkeitUmNeueMetadatenUndContainerformate}. Dynamic loading or updating of extensions automatically or triggered by the \LibName{} user is not necessary, as in most use cases it should be clear at compile-time which extensions are required. As extensions should not be introducing a big overhead, applications can easily provide all in total possible extensions at build-time already.

Last but not least, for the \LibName{} implementation, complexity is largely reduced if we omit the requirement to load, update or exchange extensions at runtime.
}
{% Nachteile
No disadvantages known
}
%%%% <-- DD %%%%

How does the library identify extensions on the class path?

%%%% DD --> %%%%
\DD{dd:241}
{% Titel
An extension is identified by implementing \texttt{IExtension} and being configured by the \texttt{ServiceLoader} facility
}
{% Kurzbeschreibung
An extensions is identified by each implementation of the \texttt{IExtension} interface that is configured in a JAR file on the class path as a service provider. It is found on the class path by the library core by using the Java \texttt{ServiceLoader} class. It does not matter if the extensions is located in a separate JAR file or even already in the core, and how much extensions are in a single JAR file.
}
{% Begründung
\texttt{ServiceLoader} is a quite convenient and very easy to use mechanism.
}
{% Nachteile
No disadvantages known
}
%%%% <-- DD %%%%

Regarding the configuration of extensions:
%%%% DD --> %%%%
\DD{dd:242}
{% Titel
There is no central configuration file listing available extensions; extensions themselves use code to provide a description of the extension and no config files
}
{% Kurzbeschreibung
Extensions are just discovered via classpath. There is no central configuration file listing all available extensions for the \LibName{} core. Furthermore, extensions themselves might provide a description, but this description is also not contained in a configuration file, but rather returned by the \texttt{IExtension} implementation directly in Java code.
}
{% Begründung
A central configuration of all available extensiosn for the \LibName{} core would be very inflexible. It would need to be extended anytime a new extension is available. And then, by whom? The end user, the developers of the extensions or even the \LibName{} developers? This would not make much sense.

For the extension specific details, a configuration file could be used, but it again makes it harder to create an extension and we would need additional generic code to parse the configurations. Configurabilty for such things is not necessary at all. If a change in the description is necessary, it would be related to changes in the extension anyway and the JAR for the extension can be updated to have the updated description. An XML file embedded in the JAR file would not bring any differences or even advantages.
}
{% Nachteile
No disadvantages known
}
%%%% <-- DD %%%%

Which functional interfaces do extensions provide in which way?

%%%% DD --> %%%%
\DD{dd:243}
{% Titel
Extensions can be queried dynamically by the library core to provide 0 to $N$ implementations for an arbitrary Java interface
}
{% Kurzbeschreibung
\COMPextensionManagement{} provides a generic method in \texttt{IExtension} where \LibName{} core components can get all implementations of any Java interface they request which are provided by the extension. The extension of course might not have such implementations. But it might also have more than one implementation.
}
{% Begründung
Although in section \SectionLink{sec:KompExt}, specific cases for the extensibility of \LibName{} were mentioned, we do not want to hard-wire this into a generic component such as \COMPextensionManagement{}. If we would do this, there would be most probably a cyclic dependency from \COMPextensionManagement{} to these components of the \LibName{} core that are extensible and thus need to load extensions.

Furthermore, we do not need to change the interface of \COMPextensionManagement{} whenever extensions might need to return implementations for any other interfaces that can be extended in future.
}
{% Nachteile
No disadvantages known
}
%%%% <-- DD %%%%

What is the lifecycle of an extension, then, and is there anything else they should do?

%%%% DD --> %%%%
\DD{dd:241b}
{% Titel
An extension is instantiated just once and then used throughout the whole application, offering a method to retrieve implementations
}
{% Kurzbeschreibung
According to \DesLink{dd:240}, an extension is loaded at \LibName{} startup. It can be considered as singleton, as just a single instance of it is loaded using \texttt{ServiceLoader}. Extensions should have the sole purpose of returning new implementation instances, for which they implement the method \texttt{IExtension.getExtensionProviders}. Anytime this method is called, they provide a list of new implementations they provide for the given interface. If they do not provide an implementation, they return an empty list. Besides that, there is a method \texttt{getExtensionDescription} where extensions can provide additional detail information for the extension.

Extensions should not do anything else. Especially, they should not have any internal mutable state or perform any background processing.
}
{% Begründung
There is no reason why extension providers should implement any special behaviour in addition to just returning implementations to use by the core, except, maybe harmful hacking code.

Of course, \LibName{} cannot really prevent that, but at least it should be made clear.
}
{% Nachteile
No disadvantages known
}
%%%% <-- DD %%%%

We should now go into more detail how the library core interacts with extensions. So far, we defined that extensions will be loaded once at startup using the \texttt{ServiceLoader} facility. But what is the public interface of the \COMPextensionManagement{} component?

%%%% DD --> %%%%
\DD{dd:244}
{% Titel
\COMPextensionManagement{} provides the interface \texttt{IExtensionsManagement} which provides access to all extensions found
}
{% Kurzbeschreibung
\COMPextensionManagement{} provides the interface \texttt{IExtensionsManagement} for the library core with the method \texttt{getAllExtensions}. This method returns all available \texttt{IExtension} implementations found.
}
{% Begründung
An easy to use \COMPextensionManagement{} without any surprises.
}
{% Nachteile
No disadvantages known
}
%%%% <-- DD %%%%

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EasyTag_DesignConcept"
%%% End:
