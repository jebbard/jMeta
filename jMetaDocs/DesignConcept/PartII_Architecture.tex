\part{Architecture}
\label{sec:Architeture}

In this part, the high-level structure of \LibName{} is defined. This is done in two refinement levels and an additional perspective:
\begin{itemize}
	\item The technical architecture shows the technical environment and parts of \LibName{}
	\item The functional architecture shows and describes the functional components of \LibName{}
\end{itemize}

%===============================================================================================
%		General Design Decisions
%===============================================================================================

\chapter{Allgemeine Designentscheidungen}
\label{sec:GeneralDesignDecisions}

In diesem Kapitel werden allgemeine Designentscheidungen getroffen, die einen unumkehrbaren Einfluss auf die Architektur der Gesamt-Library haben. Sie definieren die Rahmenbedingungen für die Library, und dienen als Basis zur Definition ihrer technischen und vorallem fachlichen Architektur. Sie bilden auch generell und übergreifend die Basis zur Erfüllung der Anforderungen, haben daher noch keinen Bezug zu einer spezifischen Anforderung.

Die Erfüllung der spezifischen Anforderungen wird durch die detaillierten Designentscheidungen ermöglicht, die im Kapitel \SectionLink{sec:FunctionalArchitectureChap} und im Teil \SectionLink{sec:Design} definiert sind.

%-----------------------------------------------------------------------------------------------
%		Design Decision: Java SE 8
%-----------------------------------------------------------------------------------------------

\section{Verwendung von Java}
\label{sec:VerwendungVonJava}

\DD{dd:001}
{% Titel
	\LibName{} basiert auf Java SE 8%
}
{% Kurzbeschreibung
	\LibName{} wird basierend auf dem ``latest update'' von Java SE 8 entwickelt. Ein Umstieg auf neuere Java-Versionen wird im Rahmen des Lebenszyklus der Library wiederholt in Erwägung gezogen.
}
{% Begründung
Java als Programmiersprache ist etabliert und weit verbreitet sowie plattformunabhängig. Prinzipiell ist der Portierungsaufwand zu anderen  Betriebssystemen, Java ME sowie Java für Smartphones (z.B. Android) damit weitaus geringer als bei Verwendung von beispielsweise C/C++. Da der Autor langjährige Erfahrung mit Java hat, stellt deren Verwendung eine höchstmögliche Produktivität sicher. Die Konkurrenzlibraries im Java-Umfeld sind überschaubar. Die aktuell (Stand 15. März 2016) neueste Version Java 8 wird ganz klar deshalb genutzt, weil die neuesten verfügbaren Features von Sprache und Library genutzt werden sollen. Java 7 hingegen wird ab voraussichtlich April 2015 von Oracle nicht mehr mit öffentlichen Updates versorft, Support ist aber weiterhin einkaufbar. Somit kann es sein, dass öffentliche Fixes für bekannte Bugs nicht mehr für Java 7 erscheinen werden.
}
{% Nachteile
Anwendungen, die auf Java 7 oder älter basieren, werden von \LibName{} nicht mehr unterstützt. Das träfe dann insbesondere auf Java-EE-Anwendungen zu, die vielfach noch auf so innovative Produkte wie Websphere 8.0 (oder älter!) aufsetzen.
}

%-----------------------------------------------------------------------------------------------
%		Design Decision: keine Dritt-Libraries
%-----------------------------------------------------------------------------------------------

\section{Verwendung anderer Libraries}
\label{sec:VerwendungAndLib}

\DD{dd:002}
{% Titel
	\LibName{} setzt so wenig wie möglich Dritt-Libraries ein
}
{% Kurzbeschreibung
	\LibName{} setzt weitestgehend allein auf die Libraries von Java SE auf. Es werden - im produktiven Code - keine Abhängigkeiten zu dritten Libraries genutzt.
}
{% Begründung
Zusätzliche Abhängigkeiten können zu Mehraufwänden bei der Verwaltung (Build, Deployment, Versionsmanagement) führen. Letztlich ist \LibName{} dann auch von der Lizenzierung, vom Release- und Bug-Management und den ``Launen'' der Library-Entwickler abhängig, was hiermit vermieden wird. Zudem wird die Anwendung insgesamt leichtgewichtiger, sowohl zur Laufzeit als auch im Hinblick auf die Auslieferungsgröße.
}
{% Nachteile
Evtl. höherer Entwicklungsaufwand, weil das Rad ab und an ``neu erfunden'' wird.
}

%-----------------------------------------------------------------------------------------------
%		Design Decision: komponentenbasiert
%-----------------------------------------------------------------------------------------------

\section{Komponentenbasierte Library}
\label{sec:KomponentenbasierteLibrary}

\DD{dd:003}
{% Titel
	\LibName{} ist komponentenbasiert
}
{% Kurzbeschreibung
	\LibName{} besteht aus sogenannten Komponenten (Definition siehe nächsten Abschnitt), die sich gegenseitig nur über klar definierte Schnittstellen verwenden.
}
{% Begründung
Die Untergliederung in Komponenten ermöglicht es, die Komplexität der Library über ihren gesamten Lebenszyklus hinweg besser zu beherrschen. Durch eine sinnvolle Komponentengliederung wird eine klare Aufgabentrennung, Entkopplung und eine bessere Erweiterbarkeit sichergestellt. Änderungen an einer Implementierung einer Komponente haben ein deutlich geringeres Risiko, sich auf weite Teile der Library auszuwirken, sondern werden lokal auf die Komponentenimplementierung beschränkt bleiben.
}
{% Nachteile
Ggf. etwas mehr overhead und mehr Komplexität, da Mechanismen zur Entkopplung eingesetzt werden müssen.
}

%-----------------------------------------------------------------------------------------------

\subsection{Definition des Komponentenbegriffs}
\label{sec:ComponentTermDefinition}

Eine \emph{Komponente} in \LibName{} ist \emph{eine abgeschlossene Software-Einheit mit klar definierter Aufgabe}. Sie bietet \emph{Services} an, die über eine klar \emph{definierte Schnittstelle} genutzt werden können. Diese Services werden sowohl von den Anwendern der Library als auch von anderen Komponenten der Library genutzt. Eine Komponente hat ggf. \emph{Datenhoheit} über bestimmte Daten, d.h. nur die Komponente selbst darf diese Daten lesen und modifizieren. Andere Komponenten müssen diese spezielle Komponente nutzen, um diese Daten zu verwenden. 

Die folgende Abbildung zeigt schmeatisch eine \LibName{} Komponente:

\begin{figure}[H]
\centering
\includegraphics[width=1.00\textwidth]{figures/II_ComponentStructure.pdf}
\caption{Struktur einer Komponente}
\label{fig:5_3_SCH_Komponente}
\end{figure}

Die Komponentenschnittstelle besteht aus einem oder mehreren Java interfaces, exceptions und Datentypen.
\begin{itemize}
	\item \emph{Java interfaces} stellen die funktionalen API der Komponente dar, jede Methode entspricht einem Service der Komponente. Ein Java interface wird für eine klar definierte Unteraufgabe der Komponente genutzt. Manche Interfaces haben Erzeugungscharakter, geben also Zugriff auf andere Interfaces der Komponente.
	\item \emph{Datentypen} sind konstante Java-Klassen, die direkt in implementierungsform zur Verfügung gestellt werden. Meist dienen sie dazu, Daten zu halten, die als Eingabe oder Rückgabe verwendet werden.
	\item \emph{Exceptions} sind Fehler die auf funktionelle Fehler hindeuten. Es handelt sich um geprüfte Exceptions, die an der Service-Schnittstelle definiert werden und vom Anwender behandelt werden müssen.
\end{itemize}

%-----------------------------------------------------------------------------------------------
%		Design Decision: Keine Schichtenarchitektur in Komponenten
%-----------------------------------------------------------------------------------------------

\subsection{Designentscheidungen zur Verwendung von Komponenten}
\label{sec:DesVerwKomp}

%-----------------------------------------------------------------------------------------------
%		Design Decision: Entkoppeln von Komponenten über ein leichtgewichtiges Service-Locator-Pattern
%-----------------------------------------------------------------------------------------------
\DD{dd:004}
{% Titel
	Entkoppeln von Komponenten über ein leichtgewichtiges Service-Locator-Pattern
}
{% Kurzbeschreibung
	Um geringe Kopplung zwischen den Komponenten zu erreichen, dürfen sich diese nur über ihre Komponentenschnittstellen kennen. Dies trifft auch für das Erzeugen anderer Komponenten bzw. das Erlangen einer Referenz auf ein anderes Komponenteninterface zu. Um dies zu erreichen, wird ein leichtgewichtiges Service-Locator-Pattern in Form einer eigenen Utility verwendet.
}
{% Begründung
Wir wollen vernünftige Entkopplung zwischen Komponenten, und daher brauchen wir eine entsprechende Utility. Diese soll leichtgewichtig sein, damit scheiden Java EE und Spring aus, Drittlibraries wie Google Guice ebenso wegen \DesLink{dd:002}.
}
{% Nachteile
 Keine erkennbar
}

%-----------------------------------------------------------------------------------------------
%		Singleton Components
%-----------------------------------------------------------------------------------------------

\DD{dd:005}
{% Titel
	Singleton-Komponenten
}
{% Kurzbeschreibung
	Jede Komponente hat eine einzelnes \emph{Zugriffs-Java-interface}, das wiederum Zugriff auf all Services der Komponente gewährt. Dazu kann das Zugriffsinterface Instanzen vefschiedener anderer Klassen oder Interfaces zurückliefern, mit denen der Aufrufer dann arbeiten kann.

Aus einer Laufzeit- und Implementierungsperspetive hat jedes der Zugriffs-Java-Interfaces eine Art ``singleton''-Implementierung. Es darf also nur eine Instanz der Zugriffs-Java-Interfaces einer Komponente geben. Natürlich darf es im Kontrast dazu mehrere Instanzen jedes anderen Interfaces geben, dass die Komponente definiert.
}
{% Begründung
Die Zugriffs-Java-Interfaces sind nur funktional, und da es nur genau eine Komponentenimplementierung in \LibName{} je Komponente gibt, hat man immer nur eine implementierende Klasse. Für diese ist zur Laufzeit nur eine Instanz erforderlich, da sie keine Zustände hält. Dies spart Speicherplatz und Initialisierungsaufwand.
}
{% Nachteile
 Keine erkennbar
}

%-----------------------------------------------------------------------------------------------
%		Design Decision: Entkoppeln von Komponenten über ein leichtgewichtiges Service-Locator-Pattern
%-----------------------------------------------------------------------------------------------

\DD{dd:006}
{% Titel
	Unterteilung in Subsysteme
}
{% Kurzbeschreibung
	Eine Ebene über den Komponenten untergliedern wir \LibName{} noch in sogenannten \emph{Subsysteme}. Ein Subsystem zerfällt in Komponenten, und hat sonst keine anderen Inhalte. Es ist also nur eine weitere Gliederungsebene. Generell ist es Komponenten innerhalb desselben Subsystems erlaubt, stärker an andere Komponenten gekoppelt zu sein, während Subsysteme untereinander eher über eine geringere Kopplung verfügen sollten. Um dies zu gewährleisten, können Subsysteme sogenannte Fassadenkomponenten anbieten.
}
{% Begründung
Anhand dieser Untergliederung können wir bereits eine grobe Architektursicht mit den wichtigsten Elementen und Abhängigkeiten definieren und auf dieser Basis die Library schrittweise weiter verfeinern.
}
{% Nachteile
 Keine erkennbar
}


%-----------------------------------------------------------------------------------------------
%		Design Decision: API and Implementation Layers
%-----------------------------------------------------------------------------------------------

\DD{dd:007}
{% Titel
	API- und Implementierungs-Layer
}
{% Kurzbeschreibung
	Jede Komponente bietet ihre Dienste, Exceptions und Datentypen über einen API-Layer an. Dieser stellt die öffentliche Schnittstelle der Komponente dar. Andere Komponenten ebenso wie der \LibName{}-Anwender dürfen die Komponente nur über diese API-Klassen verwenden. Der Implementierungs-Layer der Komponente implementiert den API-Layer und ist privat. Insbesondere sind compile-Zeit-Abhängigkeiten zu dessen Klassen von anderen Komponenten oder Anwender-Klassen aus verboten.
}
{% Begründung
  Es gibt eine Klare Trennung zwischen privaten und öffentlichen Anteilen, was die Kopplung und das Risiko von Fehlerpropagation sowie Inkompatibilitäten verringert, weil sich interne Änderungen an der Komponente idealerweise gar nicht auf nutzende Komponenten auswirken.
}
{% Nachteile
 Keine erkennbar
}

%-----------------------------------------------------------------------------------------------
%		Keine Schichtenarchitektur in der Komponenten-Implementierung
%-----------------------------------------------------------------------------------------------

\DD{dd:008}
{% Titel
	Keine Schichtenarchitektur in der Komponenten-Implementierung
}
{% Kurzbeschreibung
	Die Implementierungs-Schicht einer Komponente in \LibName{} wird nicht weiter in Unter-Schichten gegliedert (wie dies in EE-Anwendungen häufig der Fall ist). Die innere Struktur einer Komponente wird durch keine Architekturvorgaben standardisiert, sondern zweckdienlich implementiert. Eine Schichtenarchitektur wäre beispielsweise: Eine Schicht kümmert sich um das Prüfen von Vorbedingungen, eine zweite implemeniert die Funktionalität, eine dritte kümmert sich um den Zugriff auf externe Daten.
}
{% Begründung
Eine Schichtenarchitektur in der Komponentenimplementierung ist für \LibName{} nicht notwendig und verkompliziert dessen Architektur. Es handelt sich um keine klassische ``3-tier''-Anwendung, sondern eine Hilfslibrary, in welcher nur wenige Komponenten Datenzugriffe durchführen. Eine Schichtenarchitektur würde zu einer Verringerung der Übersichtlichkeit und mehr Redundanz führen, ohne nennenswerte Vorteile bei ``separation of concerns'' oder Entkopplung zu bringen.
}
{% Nachteile
 Keine erkennbar
}

%-----------------------------------------------------------------------------------------------
%		Design Decision: Entwicklungsumgebung
%-----------------------------------------------------------------------------------------------

\section{Entwicklungsumgebung}
\label{sec:entw}

\DD{dd:009}
{% Titel
	Entwicklungsumgebung
}
{% Kurzbeschreibung
	Als Entwicklungsumgebung wird eine Kombination aus Eclipse, Maven und Subversion genutzt.
}
{% Begründung
Bekannte und kostenloste Toolsuite.
}
{% Nachteile
 Keine erkennbar
}

%-----------------------------------------------------------------------------------------------
%		Design Decision: Multithreading
%-----------------------------------------------------------------------------------------------

\section{Multithreading}
\label{sec:mult}

\DD{dd:010}
{% Titel
	\LibName{} ist nicht thread-safe
}
{% Kurzbeschreibung
	\LibName{} ist keine thread-safe Library und verwendet keine Java-APIs, die thread-safe sind.
}
{% Begründung
Thread-Sicherheit bedeutet ggf. Performance-Verringerung durch Erzeugung von Synchronisationspunkten und Erhöhung der Gesamtkomplexität. Single-thread-Anwendungen werden benachteiligt. Es ist schwierig, thread-safety \emph{korrekt} umzusetzen. Anwender können selbst dafür Sorge tragen, dass ihre multi-threaded-Anwendung thread-safe ist.
}
{% Nachteile
Keine erkennbar
}

%-----------------------------------------------------------------------------------------------
%		Design Decision: Architektur
%-----------------------------------------------------------------------------------------------

\section{Architektur}
\label{sec:arch}

\DD{dd:011}
{% Titel
	Architektur von \LibName{}
}
{% Kurzbeschreibung
	\LibName{} basiert auf der technischen und fachlichen Architektur, wie sie in den Kapiteln \SectionLink{sec:TechnicalArchitectureChap} und \SectionLink{sec:FunctionalArchitectureChap} definiert wird.
}
{% Begründung
Siehe Diskussion der Architektur im Detail in den nächsten Abschnitten.
}
{% Nachteile
Siehe Diskussion der Architektur im Detail in den nächsten Abschnitten.
}

%===============================================================================================
%		Technische Archiktur
%===============================================================================================

\chapter{Technical Architecture}
\label{sec:TechnicalArchitectureChap}

%-----------------------------------------------------------------------------------------------
%		Technische Infrastruktur
%-----------------------------------------------------------------------------------------------

\section{Technical Infrastructure}
\label{sec:TechnicalInfrastructure}

The technical infrastructure describes the environment required to work with \LibName{} as shown in the following figure:

\begin{figure}[H]
\centering
\includegraphics[width=1.00\textwidth]{figures/II_TechnicalInfrastructure.pdf}
\caption{Technical infrastructure of \LibName{}}
\label{fig:5_3_SCH_TechnicalInfrastructure}
\end{figure}

The technical layers can be interpreted as dependency and communication structure. The application layer is based on \LibName{}, while \LibName{} as well as the application layer uses \JavaVersion{}. Thanks to this, the library and its using applications are platform-independent and can be used on any platform currently supported by Java. \JavaVersion{} accesses the operating system, which offers services to access the physical medium.

However, \LibName{} is only developed for \JavaVersion{} and cannot be used by applications requiring earlier versions.

Each layer only accesses the neighouring layer.

%-----------------------------------------------------------------------------------------------
%		Technische Basiskomponenten
%-----------------------------------------------------------------------------------------------

\section{Technical Base Components}
\label{sec:TechnicalBasis}

Technical base components are just helpers providing a framework and basis for the functional components of \LibName{}. With ``functional'' we are referring to the tasks of the library, i.e. reading and writing metadata and reading container data. The necessary base components are:
\begin{itemize}
	\item Logging
	\item Service-Locator to achieve a component oriented architecture
	\item Utility
	\item Maintaining extensions
\end{itemize}

Details of these components are given in \SectionLink{sec:Design}.

%===============================================================================================
%		Fachliche Architektur
%===============================================================================================

\chapter{Fachliche Architektur}
\label{sec:FunctionalArchitectureChap}

Die fachliche Architektur umfasst die Gliederung der Library-Funktionalität in fachliche Einheiten. Auf detaillierter Ebene sind dies die bereits definierten Komponenten. Auch wenn diese rein technische Funktionen umsetzen, beispielsweise Logging, werden sie in der fachlichen Architektur aufgeführt.

Hier noch einige detaillierte Designentscheidungen, die sich auf die fachliche Architektur beziehen.

%-----------------------------------------------------------------------------------------------
%		Grundlegende Designentscheidungen zur fachlichen Architektur
%-----------------------------------------------------------------------------------------------

\section{Grundlegende Designentscheidungen zur fachlichen Architektur}
\label{sec:Grld}

Die folgenden grundlegenden Designentscheidungen haben einen maßgeblichen Einfluss auf die fachliche Architektur der Library, und sie haben einen übergreifenden Effekt, sind also nicht auf einzelne Subsysteme oder Komponenten beschränkt. Daher werden sie hier definiert. Sie liefern eine generelle Begründung des später entwickelten fachlichen Designs.

%-----------------------------------------------------------------------------------------------

\DD{dd:100}
{% Titel
	High-Level- und Low-Level-API
}
{% Kurzbeschreibung
	Wir untergliedern \LibName{} in einen High-Level-Anteil, der bequeme User-Funktionalität zum Zugriff auf Metadaten bietet, und einen Low-Level-Anteil, der generische Expertenfunktionalität auf Bit- und Byte-Ebene bietet.
}
{% Begründung
Zunächst muss eine Low-Level-Zugriffsmöglichkeit gemäßt \SectionLink{sec:ANF004ZugriffAufAlleRohdatenUeberDieLibrary} zur Vergfügung gestellt werden. Statt Low-Level- und High-Level-Zugriff in einer unübersichtlichen API gemeinsam bereitzustellen, separieren wir sowohl API als auch die Implementierung dieser Belange. Aus Anwendersicht ist dann klar, welche API für ihn als ``bequem'' gedacht ist, und welche nur für detaillierten feingranularen Zugriff verwendet werden soll. Die low-level-API kann von der High-level-API aufgerufen werden, um diese zu implementieren. Dies schafft auch eine saubere Trennung in der Implementierung.
}
{% Nachteile
Ggf. höhere Komplexität der Gesamtlösung
}

%-----------------------------------------------------------------------------------------------

\DD{dd:101}
{% Titel
	Generisches Parsen und Schreiben anhand einer Format-Spezifikation
}
{% Kurzbeschreibung
	Das Parsen und Schreiben sämtlicher Metadaten- und Container-Formate wird anhand einer generellen Format-Spezifikation durch eine zentrale Komponente durchgeführt. Die Format-Spezifikation beschreibt, welche Features und Teile ein binäres Datenformat enthält, insbesondere, wie ein Datenblock dieses Formates aufgebaut ist und interpretiert werden muss. Es handelt sich also um eine Art generische Anleitung für das Parsen (und auch das Schreiben und Validieren) dieses Datenformates.

Weitere Designentscheidungen in späteren Abschnitten werden diese Designentscheidung vertiefen.
}
{% Begründung
Gemäß dem Dokument \cite{MetaComp} haben zumindest binäre Container- und Metadatenformate viele Gemeinsamkeiten, die unter anderem die Definition eines generellen Domänenmodells ermöglichen. Diese Gemeinsamkeiten lassen sich auch durch generelle Formatspezifikationen beschreiben. Statt für jedes neu zu unterstützende Datenformat komplett neuen Parse-Code schreiben zu müssen, können viele Formate durch einheitlichen (nur einmal zu testenden) generischen Parse-Code unterstützt werden. Es ist eine Entkopplung von Format-Beschreibung und Lesen/Schreiben möglich. Die Formatbeschreibung kann als Textdokument abgelegt werden. Eine Erweiterung um ein neues Format ist daher im Idealfall einzig und allein durch Erzeugen einer solchen konformen Textdatei umsetzbar. Somit ermöglicht diese Designentscheidung die Umsetzung der Anforderung \SectionLink{sec:ANF007ErweiterbarkeitUmNeueMetadatenUndContainerformate}.
}
{% Nachteile
Es kann nicht für jedes denkbare zukünftige Format sichergestellt werden, dass die Möglichkeiten der Format-Spezifikation ausreichen, um alle Features des jeweiligen Formates wirklich abzudecken. Dies kann zur Notwendigkeit führen, die Format-Spezifikation zu erweitern und damit auch das generische Parsen. Alternativ kann dies durch Möglichkeiten ausgeglichen werden, das Parsen doch selbst umzusetzen (und eine entsprechende Implementierung statt der generischen zu verwenden). Weiterer Nachteil: Evtl. leichter Performance-Verlust, da das generische Parsen natürlich viele verschiedene Fälle unterstützen muss.
}

%-----------------------------------------------------------------------------------------------

\DD{dd:102}
{% Titel
	Überschreiben des generischen Parsens und und Schreibens
}
{% Kurzbeschreibung
	Erweiterungen können für ihre Datenformate den generischen Lese- und Schreibvorgang (siehe \DesLink{dd:101}) überschreiben und erweitern, um sie an spezielle Gegebenheiten ihres Datenformates besser anzupassen.
}
{% Begründung
Dies minimiert die Nachteile von \DesLink{dd:101} und ermöglicht in Einzelfällen einfacherer oder performantere Implementierungen.
}
{% Nachteile
Keine erkennbar
}

%-----------------------------------------------------------------------------------------------

\DD{dd:103}
{% Titel
	Format-Spezifika werden nur in Erweiterungen definiert
}
{% Kurzbeschreibung
	Jegliche Spezifika eines Metadaten- oder Containerformates werden ausschließlich über Erweiterungen implementiert, das gilt selbst für Datenformate, die direkt mit der Kernversion von \LibName{} unterstützt werden.
}
{% Begründung
So wird bereits mit der Kernlibrary selbst das Erweiterungskonzept genutzt und erprobt. Es findet eine strikte Trennung zwischen Kernimplementierung und Format-Spezifika statt, was eine bessere Beherrschung der Gesamt-Komplexität ermöglicht.
}
{% Nachteile
Keine erkennbar
}

%-----------------------------------------------------------------------------------------------

\DD{dd:104}
{% Titel
	Fassadenkomponenten für High-Level- und Low-Level-Anteile
}
{% Kurzbeschreibung
	Die Subsysteme \SUBSHighLevel{} und \SUBSLowLevel{} verfügen über je eine Fassadenkomponente, die Zugriff auf die anderen \emph{öffentlichen} Komponenten des jeweiligen Subsystems gewähren. ``Öffentlich'' sind diejenigen Komponenten, die vom Anwender oder von \SUBSBootstrap{} direkt zugegriffen werden müssen.
}
{% Begründung
Das Subsystem \SUBSBootstrap{} muss keine direkte Abhängkeit zu den Komponenten der Subsysteme der High-Level- und Low-Level-Anteile eingehen, sondern gibt nur eine Instanz der Fassadenkomponenten zurück, dies verringert die Kopplung. Spezielle Methoden zum Zugriff auf die anderen Komponenten des Subsystems können in den Fassadenkomponenten bereitgestellt werden und müssen nicht im Subsystem \SUBSBootstrap{} bereitgestellt werden (was auch nicht der Aufgabe von \SUBSBootstrap{} entsprechen würde).
}
{% Nachteile
Keine erkennbar
}

%-----------------------------------------------------------------------------------------------

\DD{dd:105}
{% Titel
	Technische Basiskomponenten bilden ein eigenes Subsystem ohne Fassade
}
{% Kurzbeschreibung
	Alle technischen Basiskomponenten bilden ein eigenes Subsystem und werden nicht zusammen mit fachlichen Komponenten in ein Subsystem aufgenommen. Es wird keine Fassadenkomponente zum Zugriff auf die Basiskomponenten bereitgestellt.
}
{% Begründung
Um die Kohärenz der Subsysteme zu erhalten, werden die technischen Komponenten in ein eigenes Subsystem ausgelagert. Die technischen Basiskomponenten können als sogenannte ``0-Software'', d.h. perfekt wiederverwendbare Software betrachtet werden. Sie haben keine inhaltlich-fachliche Funktionen und sollten (in den meisten Fällen) keine weiteren Abhängigkeiten zu anderen Komponenten haben. Da sie alle recht spezifische und umfangreiche Funktionalität anbieten, macht ein Verwenden einer Fassadenkomponenten keinerlei Sinn. Diese würde einerseits viele unterschiedliche Belange, die nicht verwandt sind, in ein Interface zwängen, und andererseits  keineswegs zu geringerer Kopplung führen.
}
{% Nachteile
Keine erkennbar
}

%-----------------------------------------------------------------------------------------------
%		Subsysteme
%-----------------------------------------------------------------------------------------------

\section{Subsysteme}
\label{sec:Subsystems}

Die Unterteilung in Subsysteme zeigt bereits grob die wichtigsten Teile der Library und erste Abhängigkeiten zwischen ihnen. Über Subsysteme verorten wir auch den Begriff der \emph{Erweiterung}. Zudem bildet sich hier direkt die Designentscheidung \DesLink{dd:100} ab.

Das folgende Architekturbild zeigt die Subsysteme von \LibName{} und ihre Beziehungen zueinander. Ein Pfeil bedeutet dabei eine hier noch nicht näher konkretisierte Abhängigkeit, die sich entweder als Compile-Zeit- oder als Laufzeit-Abhängigkeit oder beides manifestieren kann.

\begin{figure}[H]
\centering
\includegraphics[width=1.00\textwidth]{figures/II_FunctionalArchitecture.pdf}
\caption{Subsysteme von \LibName{}}
\label{fig:5_3_SCH_TechnicalArchitecture}
\end{figure}

Der Anwender der Library kann direkt auf die Subsysteme \SUBSBootstrap{}, \SUBSExtension{}, \SUBSHighLevel{} und \SUBSLowLevel{} zugreifen, während die \SUBSTechBase{} nicht zugreifbar ist.

Die Subsysteme werden im Folgenden weiter konkretisiert.

%-----------------------------------------------------------------------------------------------

\subsection{\SUBSBootstrap{}}
\label{sec:Bootstrap}

Dieses Subsystem kapselt alle Initialisierungen von \LibName{}. Das Subsystem ist der Eintrittspunkt der Benutzung von \LibName{} für den Anwender. Es nutzt daher alle anderen Subsysteme, um diese zu initialisieren.

Die Komponenten des Subsystems sind im Abschnitt \SectionLink{sec:KompBoots} aufgeführt.

%-----------------------------------------------------------------------------------------------

\subsection{\SUBSHighLevel{}}
\label{sec:LibName2}

Die High-Level-Anteile der Library gemäß \DesLink{dd:100}. Das Subsystem greift auf \SUBSTechBase{} und \SUBSLowLevel{} zu. Letzteres deshalb, weil gemäß \DesLink{dd:100} die Implementierung der High-Level-Anteile durch Verwendung der low-level-Anteile erfolgt.

Die Komponenten des Subsystems sind im Abschnitt \SectionLink{sec:KompHigh} aufgeführt.

%-----------------------------------------------------------------------------------------------

\subsection{\SUBSLowLevel{}}
\label{sec:CoreAndUserInterface}

Die Low-Level-Anteile der Library gemäß \DesLink{dd:100}. Greift nur auf die technische Basis zu.

Die Komponenten des Subsystems sind im Abschnitt \SectionLink{sec:KompLow} aufgeführt.

%-----------------------------------------------------------------------------------------------

\subsection{\SUBSTechBase{}}
\label{sec:Techbase}

Eine Sammlung von Komponenten, die als technische Rahmenkomponenten betrachtet werden können und keine fachlich-inhaltlichen Beiträge zum Thema ``Metadaten/Container'' liefern. Sie werden von so gut wie allen anderen Subsystemen benötigt.

Die Komponenten des Subsystems sind im Abschnitt \SectionLink{sec:KompTB} aufgeführt.

%-----------------------------------------------------------------------------------------------

\subsection{\SUBSExtension{}}
\label{sec:Extensions}

\LibName{} erlaubt eine beliebige Anzahl an Erweiterungen, jede davon entspricht in der fachlichen Architektur einem Subsystem.

Details finden sich im Abschnitt \SectionLink{sec:KompExt}.

%-----------------------------------------------------------------------------------------------
%		Komponenten-Steckbrief
%-----------------------------------------------------------------------------------------------

\section{Komponenten-Steckbrief}
\label{sec:StructureofaComponentDescription}

Da in den folgenden Abschnitten Komponenten einführend beschrieben werden, wird hier ein Steckbrief, d.h. eine grundlegende Beschreibungsstruktur für eine Komponentengrobbeschreibung definiert. Dieser Steckbrief wird dann in den folgenden Abschnitten für jede Komponente ausgefüllt.

\textbf{Komponenten-Name:} Der Name der Komponente.

\textbf{Aufgabe:} Die Aufgabe der Komponente.

\textbf{Kontrollierte Daten:} Die Daten, die durch die Komponente kontrolliert werden, d.h. gelesen und geschrieben werden. Nutzt die Komponente Daten anderer Komponenten, wird dies hier nicht erwähnt.

\textbf{Abhängig von $<$Komponenten-Name$>$:} Dieses Element kommt mehrfach je Komponente vor, von der diese Komponente abhängt. Der Grund für die Abhängigkeit wird kurz erläutert.

%-----------------------------------------------------------------------------------------------
%		Komponenten des Subsystems \SUBSBootstrap{}
%-----------------------------------------------------------------------------------------------

\section{Komponenten des Subsystems \SUBSBootstrap{}}
\label{sec:KompBoots}

Die folgende Abbildung zeigt die Komponenten des Subsystems \SUBSBootstrap{}.

\OpenIssue{Bootstrap subsystem Componenten Abbildung}{}
%\begin{figure}[H]
	%\centering
		%\includegraphics[width=1.00\textwidth]{Figures/Part_III/III_1_SUBSBootstrap.pdf}
	%\caption{Komponenten des Subsystems \SUBSBootstrap{}}
	%\label{fig:CompSB}
%\end{figure}

%-----------------------------------------------------------------------------------------------

\subsection{Komponente \COMPcontext{}}
\label{sec:COMPContext}

\textbf{Komponenten-Name:} \COMPcontext{}.

\textbf{Aufgabe:} Der Einstiegspunkt für jeden User von \LibName{}. Es ermöglicht Zugriff auf alle anderen Komponenten der Library.

\textbf{Kontrollierte Daten:} Keine.

\textbf{Abhängig von \COMPlowLevel{}:} \COMPcontext{} gibt Zugriff auf die Komponente \COMPlowLevel{}.

\textbf{Abhängig von \COMPhighLevel{}:} \COMPcontext{} gibt Zugriff auf die Komponente \COMPhighLevel{}.

\textbf{Abhängig von \COMPextensionManagement{}:} \COMPcontext{} lädt alle Erweiterungen unter Nutzung dieser Komponente.

\textbf{Abhängig von \COMPlogging{}:} \COMPcontext{} nutzt diese Komponente zur Protokollierung des Startup-Prozesses.

\textbf{Abhängig von \COMPcomponentRegistry{}:} \COMPcontext{} nutzt diese Komponente zum Instantiieren bzw. Abfragen von Implementierungen anderer verwendeter Komponenten-Interfaces.

\textbf{Abhängig von \COMPutility{}:} \COMPcontext{} nutzt diverse querschnittliche Funktionen von \COMPutility{}.

%-----------------------------------------------------------------------------------------------
%		Komponenten des Subsystems \SUBSHighLevel{}
%-----------------------------------------------------------------------------------------------

\section{Komponenten des Subsystems \SUBSHighLevel{}}
\label{sec:KompHigh}

Die Komponenten des Subsystems \SUBSHighLevel{} werden in dieser Version der Library noch nicht definiert.

%-----------------------------------------------------------------------------------------------
%		Komponenten des Subsystems \SUBSLowLevel{}
%-----------------------------------------------------------------------------------------------

\section{Komponenten des Subsystems \SUBSLowLevel{}}
\label{sec:KompLow}

Die folgende Abbildung zeigt die Komponenten des Subsystems \SUBSLowLevel{}.
\OpenIssue{Container API subsystem Abbildung}{}

%\begin{figure}[H]
	%\centering
		%\includegraphics[width=1.00\textwidth]{Figures/Part_III/III_1_SUBSLowLevel.pdf}
	%\caption{Komponenten des Subsystems \SUBSLowLevel{}}
	%\label{fig:CompLL}
%\end{figure}

%-----------------------------------------------------------------------------------------------

\subsection{\COMPlowLevel{}}
\label{sec:COMPlowLevel}

\textbf{Komponenten-Name:} \COMPlowLevel{}.

\textbf{Aufgabe:} Fassadenkomponente. Gewährt allen Anwendern Zugriff auf die anderen öffentlichen Komponenten dieses Subsystems.

\textbf{Kontrollierte Daten:} Keine.

\textbf{Abhängig von \COMPdataPartManagement{}:} Gewährt Zugriff auf diese Komponente.

\textbf{Abhängig von \COMPdataFormatManagement{}:} Gewährt Zugriff auf diese Komponente.

%-----------------------------------------------------------------------------------------------

\subsection{\COMPdataPartManagement{}}
\label{sec:COMPdataPartManagement}

\textbf{Komponenten-Name:} \COMPdataPartManagement{}.

\textbf{Aufgabe:} Gewährt lesenden Zugriff auf Metadaten und Containerdaten und schreibenden Zugriff auf Metadaten auf Bit- und Byte-Ebene, allerdings werden die Daten in handlichen Portionen gemäß Datenformat-Spezifikation geliefert.

\textbf{Kontrollierte Daten:} Ein Zugriff auf \TERMcontainer{}- und \TERMtag{}-Daten ist nur über diese Komponente erlaubt. Somit hat sie die Kontrolle über diese Daten. Lediglich \COMPmedia{} darf auf noch generischerer Ebene auf Daten externer Medien zugreifen. Tatsächlich nutzt \COMPdataPartManagement{}  \COMPmedia{} für das Lesen und Schreiben.

\textbf{Abhängig von \COMPmedia{}:} \COMPdataPartManagement{} muss Datenpakete von Medien lesen oder auf diese Schreiben. Dazu nutzt es \COMPmedia{}.

\textbf{Abhängig von \COMPdataFormatManagement{}:} Das Lesen und Schreiben der Daten erfolgt anhand von Format-Spezifikationen, die durch \COMPdataFormatManagement{} geliefert werden.

%-----------------------------------------------------------------------------------------------

\subsection{\COMPdataFormatManagement{}}
\label{sec:COMPdataFormatManagement}

\textbf{Komponenten-Name:} \COMPdataFormatManagement{}.

\textbf{Aufgabe:} Verwaltet die konkreten Datenformat-Definitionen aller unterstützten Metadaten- und Container-Formate.

\textbf{Kontrollierte Daten:} Hat Kontrolle über die Datenformat-Definitions-Daten.

\textbf{Abhängig von:} Keinen anderen Komponenten.

%-----------------------------------------------------------------------------------------------

\subsection{\COMPmedia{}}
\label{sec:COMPmediumAccess}

\textbf{Komponenten-Name:} \COMPmedia{}.

\textbf{Aufgabe:} Bietet Primitive für den Zugriff auf physische Medien an.

\textbf{Kontrollierte Daten:} Daten von externen Medien dürfen nur über diese Komponente zugegriffen und manipuliert werden.

\textbf{Abhängig von:} Keinen anderen Komponenten.

%-----------------------------------------------------------------------------------------------
%		Komponenten des Subsystems \SUBSTechBase{}
%-----------------------------------------------------------------------------------------------

\section{Komponenten des Subsystems \SUBSTechBase{}}
\label{sec:KompTB}

Die folgende Abbildung zeigt die Komponenten des Subsystems \SUBSTechBase{}.
\OpenIssue{Tech Base subsystem Abbildung}{}
%\begin{figure}[H]
	%\centering
		%\includegraphics[width=1.00\textwidth]{Figures/Part_III/III_1_SUBSTechBase.pdf}
	%\caption{Komponenten des Subsystems \SUBSTechBase{}}
	%\label{fig:CompTB}
%\end{figure}

%-----------------------------------------------------------------------------------------------

\subsection{\COMPextensionManagement{}}
\label{sec:COMPextensionManagement}

\textbf{Komponenten-Name:} \COMPextensionManagement{}.

\textbf{Aufgabe:} Verwaltet alle Erweiterungen von \LibName{}, d.h. laden, verifizieren und Auslesen von Informationen zu jeder Erweiterung.

\textbf{Kontrollierte Daten:} Beschreibungsdaten der Erweiterungen können nur über diese Komponente geladen werden.

%-----------------------------------------------------------------------------------------------

\subsection{\COMPlogging{}}
\label{sec:COMPlogging}

\textbf{Komponenten-Name:} \COMPlogging{}.

\textbf{Aufgabe:} Bietet Primitive zum Ausgeben von Logging-Informationen.

\textbf{Kontrollierte Daten:} Logging-Konfiguration.

\textbf{Abhängig von:} Keiner anderen Komponente.

%-----------------------------------------------------------------------------------------------

\subsection{\COMPutility{}}
\label{sec:COMPutility}

\textbf{Komponenten-Name:} \COMPutility{}.

\textbf{Aufgabe:} Bietet diverse (technische) Querschnittsfunktionen, die von allen anderen Komponenten regelmäßig benötigt werden, z.B. Hilfsfunktionen zur Umsetzung von design-by-contract.

\textbf{Kontrollierte Daten:} Keine.

\textbf{Abhängig von:} Keiner anderen Komponente.

%-----------------------------------------------------------------------------------------------

\subsection{\COMPcomponentRegistry{}}
\label{sec:COMPcomponentRegistry}

\textbf{Komponenten-Name:} \COMPcomponentRegistry{}.

\textbf{Aufgabe:} Technische Komponente mit Service-Locator-Funktionalität zum Abfragen der Implementierungen von Interfaces anderer Komponenten.

\textbf{Kontrollierte Daten:} Konfiguration von Komponenten, Interfaces und ihren Implementierungen.

\textbf{Abhängig von:} Keiner anderen Komponente.

%-----------------------------------------------------------------------------------------------
%		Erweiterungen (Subsystem \SUBSExtension{})
%-----------------------------------------------------------------------------------------------

\section{Extensions (Subsystem \SUBSExtension{})}
\label{sec:KompExt}

An \emph{Extension} summarizes format-specific content for a given data format (or multiple variations of the data format). Per data format defined by the extension, these are (compare \DesLink{dd:101}, \DesLink{dd:102} and \DesLink{dd:103}):
\begin{itemize}
	\item A data format specification which defines data blocks and their structure and relations
	\item An end-user API to comfortably work with the data format (e.g. creation of data blocks etc.); this API especially holds the data format identifier which the user can use to work with \SUBSHighLevel{} and \SUBSLowLevel{}.
	\item Implementation extensions for \SUBSLowLevel{}, which influence the parsing and writing process. With this mechanism, a data format can extend or override the standard parsing and writing algorithms defined in \SUBSLowLevel{}.
\end{itemize}

As a ground rule, every single extension can but should not define extension code for more than one data format. It might expose more data formats only if these two data formats heavily overlap and are based on each other, e.g. ID3v1 and ID3v1.1. This is to fulfill the requirement \SectionLink{sec:ANF010SchreibenInAnderesAusgabemediumUnterstützt}.

Moreover, distinct extensions should never depend on each other, but only on the \LibName{} core to avoid any confusion for the user.

%###############################################################################################
%###############################################################################################
%
%		File end
%
%###############################################################################################
%###############################################################################################


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "jMetaDesignConcept"
%%% End: