%===============================================================================================
%		Requirements
%===============================================================================================

\part{Requirements}
\label{sec:Analyse}

This chapter defines the most important functional and non-functional requirements for \LibName{}.
Most relevant input is the document \cite{MetaComp}.

%===============================================================================================
%		Scope
%===============================================================================================

\chapter{Scope}


% -------------------------------------------------------------------------------------------------------
%  In Scope
% -------------------------------------------------------------------------------------------------------
\section{In Scope}%
\label{sec:InScope}%

\LibName{} is a Java library for reading and writing container and metadata formats. \LibName{} has the following goals:
\begin{itemize}
\item Define a robust, easy to use and generic API for reading and writing multimedia (i.e. audio, video and image) metadata
\item In addition, define a way to also parse and change typical container formats that embed or surround multimedia metadata
\item Be easily extensible with additional metadata or container formats, also by third party
\end{itemize}

Thus, clearly, \LibName{} targets applications and users in the multimedia editing area, e.g. software to manage an audio, video or image collection.

Special strenght of the library should be its versatility (in a sense of supported formats and generality) as well as its extensibility. At the same time, it targets to offer access to ALL features of each specific format, even the low-level ones, and thus does not want to hide anything from expert users who need fine-grained control.

Using \LibName{}, an application is allowed to access metadata quite generically and comfortably, or it can also explore deep specifics of each format down to the bit and byte level.

% -------------------------------------------------------------------------------------------------------
%  Out of Scope
% -------------------------------------------------------------------------------------------------------
\section{Out of Scope}%
\label{sec:OutofScope}%

Metadata not in the audio, video or image domain are not directly in scope of \LibName{} and thus the library might not offer the right abstractions for those. However, it is at least likely that other binary or textual formats can also be parsed quite the same way using \LibName{}.

Furthermore, \LibName{} clearly is no encoding or decoding library, it cannot understand codecs. It might however help to encode or decode by providing access to the low-level details of the container formats. It might be used as basis for extensible encoders or decoders, however, not exactly in high-performance areas where speed is of most importance. 

Further things out of scope of specific versions are treated in \SectionLink{sec:Requirements}.

%-----------------------------------------------------------------------------------------------
%		Features of version \LibVersion{}
%-----------------------------------------------------------------------------------------------

\section{Features of version \LibVersion{}}
\label{sec:FeaturesLibVersion}

Here we give a brief overview of the features the library needs to offer in version \LibVersion{}. It is the first version of the library, so its goal is the bare minimum: Implement all core features and support some of the most important data formats. Image and video formats are not yet in scope of this version. 

%-----------------------------------------------------------------------------------------------

\subsection{Supported Metadata Formats}
\label{sec:UnterstuetzteMetadatenformate}

This version adds support for the following audio metadata formats:

\begin{itemize}
\item ID3v1 and ID3v1.1
\item ID3v2.3
\item APEv2
\item Lyrics3v2
\end{itemize}

%-----------------------------------------------------------------------------------------------

\subsection{Supported Container Formate}
\label{sec:UnterstuetzteContainerformate}

This version adds support for the following audio container formats:

\begin{itemize}
\item MPEG-1 Audio Layer 3 (MP3)
\end{itemize}

%-----------------------------------------------------------------------------------------------

\subsection{Supported Input Media}
\label{sec:UnterstuetzteEingabemedien}

This version adds support for the following data sources for reading data:
\begin{itemize}
\item Files
\item Java \texttt{InputStream}s
\item Java byte arrays
\end{itemize}

%-----------------------------------------------------------------------------------------------

\subsection{Supported Output Media}
\label{sec:UnterstuetzteAusgabemedien}

This version adds support for the following output media for writing data:
\begin{itemize}
\item Files
\item Java byte arrays
\end{itemize}

%-----------------------------------------------------------------------------------------------
%		Related Libraries
%-----------------------------------------------------------------------------------------------

\section{Related Libraries}
\label{sec:RelatedLibraries}

Here, related Java libraries are treated that are related to what \LibName{} offers. This includes existing productive Java libraries in the area of multimedia, which can be considered as open source competitors to \LibName{} on the one hand, on the other hand, they provide inspiration, possible reuse and also warning examples how to not do it.

%-----------------------------------------------------------------------------------------------

\subsection{Metadata Libraries}
\label{sec:MetadataLibraries}


A selection of libraries offering access to multimedia metadata as of end of 2017, mostly audio metadata - One source for this e.g. is \url{http://id3.org/Implementations} and Google:

\begin{landscape}
\begin{longtable}{|p{0.18\linewidth}|p{0.22\linewidth}|p{0.18\linewidth}|p{0.07\linewidth}|p{0.25\linewidth}|}
	\hline
	\rowcolor[gray]{.9}\textbf{Library} & \textbf{URL} & \textbf{Supported Formats} & \textbf{Lines of Code} & \textbf{Comments} \\
	\endhead
	\hline
\textbf{jaudiotagger (Java)} & \url{http://www.jthink.net/jaudiotagger/} &  MP3, MP4, Ogg Vorbis, Flac, WMA, partly WAV and Real Audio & $>86000$ & Obscure class and package structure, more than 500 classes, just a few testcases only (?), still actively developed \\
	\hline
\textbf{jLayer and JavaZoom (Java)} & \url{http://www.javazoom.net/index.shtml} & MP3, WAV, ID3v1, ID3v2 & $>13600$ & Project targeting MP3 decoding and playing of MP3s \\
	\hline
\textbf{mp3agic (Java)} & \url{https://github.com/mpatric/mp3agic} & ID3 Tags (1.0, 1.1, 2.3, 2.4), Read-only ID3 v2.2, MP3 low-level reading (incl. VBR) & $>5500$ & Still actively developed \\
	\hline
\textbf{BeagleBuddy (Java)} & \url{http://www.beaglebuddy.com/} & Reads and writes ID3 Tags (1.0, 1.1, 2.3, 2.4), Lyrics3v2, Lyrics3v1, APEv1, APEv2, reads MP3 files CBR and VBR, Xing, LAME, and VBRI Header & $>40700$ & Focus on being ``easy to use''; Last version in beginning of 2015 \\
	\hline
\textbf{JID3 (Java)} & \url{https://blinkenlights.org/jid3/}, \url{https://java.net/projects/jid3lib} & ID3v1, ID3v2.2 and ID3v2.3; no ID3v2.4 support & $>30000$ & Seems to be dead (last version 0.46 in 2005) \\
 	\hline
\textbf{Javamusictag (Java)} & \url{http://javamusictag.sourceforge.net/} & MP3, ID3v1, ID3v1.1, Lyrics3v1, Lyrics3v2, ID3v2.2, ID3v2.3, and ID3v2.4 & $>27000$ & Seems to be the same thing or a fork of JID3 \\
 	\hline
\textbf{Xuggler (Java)} & \url{http://www.xuggle.com/xuggler} & MP3, Ogg (Vorbis, Speex), Flac, AAC, ID3v2 and others & - & Decoder and editing API for various audio and video formats \\
	\hline
\textbf{jFlac (Java)} & \url{http://jflac.sourceforge.net/} & FLAC, VorbisComment & - & Especially encoding and decoding of FLAC \\
	\hline
\textbf{MPEG-7 Audio Encoder (Java)} & \url{http://mpeg7audioenc.sourceforge.net/} & MPEG-7 & - & Creates MPEG-7 metadata \\
	\hline
\textbf{JAI Image I/O (Java)} & \url{https://jai-imageio.dev.java.net/binary-builds.html} & EXIF & - & Can read and write EXIF tags from a variety of embedding formats \\
	\hline
\textbf{jmac (Java)} & \url{http://sourceforge.net/projects/jmac/} & APE, MonkeyAudio & - & \\
	\hline
 \textbf{MyID3 (Java)} & \url{https://github.com/jkauflin/jjkMP3} & Audio-Metadaten (ID3) & - & Private engagement, not really to be taken seriously \\
	\hline
\textbf{id3lib (C/C++)} & \url{http://id3lib.sourceforge.net/} & Audio-Metadaten (ID3) & - & \\
	\hline
\textbf{Mutagen (Python)} & \url{http://pypi.python.org/pypi/mutagen/1.12} & Audio-Metadaten und -Container-Daten (ID3) & & \\
	\hline
\caption{Competitor libraries compared}
\label{tab:Compet}
\end{longtable}
\end{landscape}

The analysis shows that as of now, the biggest competitors would be jAudioTagger, mp3agic, BeagleBuddy and JID (which seems dead) from a metadata perspective and Xuggler as well as jLayer from decoding and editing perspective (if \LibName{} should ever try to go into this direction).

%***********************************************************************************************

\subsubsection{Drawbacks of Existing Metadata Libraries}
\label{sec:DrawbacksofExistingMetadataLibraries}

Each of the mentioned libraries specializes itself to just a few formats. Saying this, applications are only likely to be satisfied with them if they just need to support those formats. If they do require more, they need to use multiple libraries or extend the existing ones or wait for new features.

Second, the architecture and extensibility of the existing libraries is not convincing. Most of the ID3 libraries e.g. open-heartedly show their very internals, which does not make it clear what really distinguishes ``public API'' and the private parts - with the usual consequences. Users might rely on private implementation aspects that are changed later, or if it is known that users do so for specific parts, the library evolution might get constrained by this, forcing duplication and maintenance of actually obsolete code.

Another smell of most of the libraries is their sheer volume: While mp3agic still seems humble in terms of ``only'' about 6000 lines of code (including comments and blank lines), it also does not offer so much features. The other libraries can really be considered big, topping to about over 86000 lines of code for jaudiotagger. These libraries also do not show an obvious structure or core concepts springing to one's eyes. Maintainability and especially extensibility of such rather ``hardcoded'' libraries might be not too easy.    

Users / software needing to support a broad variety of formats - when using these formats - likely need to implement a kind of plugin mechanism for easier extensibility themselves.

%***********************************************************************************************

\subsubsection{Advantages of  \LibName{}}
\label{sec:AdvantagesofLibName}

There are alreads so much library - why do we need \LibName{}? If it wants to do things better, a lot of effort is required. Is that worth it?

There are multiple aspects where \LibName{} can do better than existing libraries:
\begin{itemize}
\item \LibName{} should target container formats on a very abstract and generic level, yet still providing access to the bare details of each format; this can go as far as providing a generic framework for parsing and writing any multimedia container format, may it be audio, video, image or text content.
\item Applications whose core asset is extensibility and rich variety of supported formats do not have to use a dozen or so third party libraries having completely different programming, license and support models as well as performance characteristics - provided \LibName{} actually offers support for all formats, which is of course not necessarily the case
\item However, at least such applications do not need to reinvent the wheel by coding their own extensibility mechanism, but they just rely on the extensibility mechanism by using \LibName{}; they can code their own \LibName{} extension to support another format. The goal of \LibName{} is that doing so is easier for such applications than using another 3rd party library to enable support for such a format.
\item Still, \LibName{} is not a huge Uber JAR containing all supported formats, but it is modular, where applications just need the core of the library plus an extension module per format they want to support.
\item \LibName{} also targets to offer an easy to learn and use API for such applications.
\end{itemize}

All that said, the benchmark for how good \LibName{} really is, is as follows:
\begin{itemize}
\item It should be easier to use as BeaglyBuddy which claims to be easy to use
\item It should be much less complex (means to say: much less classes and lines of code) than jaudiotagger or BeagleBuddy
\item Supporting a new, averagely complex, previously unsupported data format does not take an experienced Java programmer (who never did write a \LibName{} extension) more than one man day!
\item Likewise, we also want to compete with other libraries in terms of performance: \LibName{} must at least be comparatively fast as the most important competitors for Java, ideally of course it should be faster
\end{itemize}

%-----------------------------------------------------------------------------------------------

\subsection{Multimedia Libraries}
\label{sec:MultimediaLibraries}

Can \LibName{} cooperate, i.e. reuse or integrate with existing Java multimedia libraries? This question is not really answered in the following sections. The general answer is: No, \LibName{} will neither be some kind of plugin for the existing libraries, nor will it depend on them, nor will it consider the requirement of easy cooperation or integration with this libraries in any way.

For now, we just want to see what is existing in the wild in terms of Java multimedia libraries, mostly audio and video. This evaluation might point future directions for \LibName{} if it goes to probably superseding or extending the existing options.

All or most of the multimedia libraries listed here seem to offer some way of reading or writing multimedia metadata. But mostly, these libraries focus on streaming, playing, encoding and decoding on high performance. The metadata is just a side-product that seems to be offered most of the time via a rather inconvenient API.

% -------------------------------------------------------------------------------------------------------
\subsubsection{Xuggler and Humble Video}%
\label{sec:Xuggler}%

Cite from the ebsite: ``Xuggler is the easy way to uncompress, modify, and re-compress any media file (or stream) from Java. ... Xuggler allows Java programs to decode, encode, and experience (almost) any video format.''

It does not seem to be based on GStreamer or FFMPEG or JMF. It does not become clear which formats are supported by the library.

The official Github page of Xuggler states it is outdated and humble video should be used. The name suggests Humble Video is mainly focused on video, not audio such as MP3.

% -------------------------------------------------------------------------------------------------------
\subsubsection{JLayer}%
\label{sec:JLayer}%

Cite for JLayer: ``JLayer is a JAVA library that decodes, converts and plays MP3 files in real-time. JLayer supports MPEG 1/2/2.5 Layer 1/2/3 audio format. JLayer doesn't need JMF.''

It does also not seem to rely on GStreamer or FFMPEG but seems to be a ``native'' Java only implementation for encoding and decoding MP3 audio data.

% -------------------------------------------------------------------------------------------------------
\subsubsection{Java FX and GStreamer}%
\label{sec:JavaFX}%

JavaFX is an Oracle library to support with platform-independent handling of user interfaces as well as multimedia content. So, it is not only ``GUI'' that actually replaces Swing and AWT, but also handling of images, video and audio content as well as even 3D graphics, thus somewhat replacing the obsolete Java 3D.

So it has a quite broad usage space. However, there is also some muttering that it might be dead or at least does not have a bright future.

For local GUIs it might still be a good option. What about multimedia playback, editing etc.? The media engine part of JavaFX is based on GStreamer. GStreamer is an extensive audio and video library written in C and nevertheless platform-independent by being ported to a lot of platforms and architectures. It also supports reading and writing tags, but in a very specific generic API which does not offer too much comfort. But how does this go together with JavaFX? First of all, GStreamer also offers a Java binding, i.e. can be called from Java applications where any installed GStreamer plugins for formats can also be used. This interface is most probably also used by JavaFX. JavaFX then offers a class named MediaPlayer with a method chain \texttt{getMedia().getMetadata()}, just returning a map (String to Object). There seems to be no documentation which objects might get returned. Furthermore it just seems to be read-only, there does not seem to be any way of writing tags with JavaFX.

% -------------------------------------------------------------------------------------------------------
\subsubsection{FFMPEG}%
\label{sec:FFMPEG}%

FFMPEG can be seen as direct competition to GStreamer, being a platform-independent framework and toolkit to record, convert and stream audio and video content. It is also written in C/C++ and supports a variety of formats. 

%***********************************************************************************************

\subsubsection{JMF and FMJ}
\label{sec:JMF}

The Java Media Framework is an official Java library that is delivered with J2SE \emph{desktop} technology. The most recent version is 2.1.1e and dating back to 2001. Which actually means: It is dead. However, we still consider it a bit here. JMF can be used by Client as well as server applications. JMF was packaged with an MP3 decoder and encoder until 2002, but removed due to licensing issues. Since 2004 there is an MP3 playback only plug-in.\footnote{see \cite{WikJMF}.}

FMJ is an Open Source Alternative, that is API compatible: \url{http://www.fmj-sf.net/}. But FMJ also seems to be dead.

JMF comes in four JAR files:\footnote{Siehe \cite{WikJMF}.}
\begin{itemize}
\item JMStudio: Simple multimedia player application
\item JMFRegistry: An application to manage different JMF settings and plug-ins
\item JMFCustomizer: Allows creation of a simple JMF JAR file containing only those JMF classes needed by the client application
\item JMFInit: Inititializes a JMF application
\end{itemize}

JMF contains platform-specific \emph{performance packs}, i.e. optimized packtes for Linux, Solaris or Windows.

%***********************************************************************************************

\paragraph{Features:}
\label{sec:Features}

JMF deals with time-based media. The JMF features can be summed up as follows:\footnote{Siehe \cite{JMFWeb}.}
\begin{itemize}
\item Capture: Read multimedia frame data of a given audio or video signal and encode it into a specific codec in realtime.
\item Playback: Play multimedia data, i.e. display videos on screen or play music on audio output devices.
\item Stream: Access multimedia streams
\item Transcode: Convert media data of a given codec into another codec without first needing to decode
\end{itemize}

%***********************************************************************************************

\paragraph{Criticism:}
\label{sec:Criticism}

\cite{WikJMF} summarizes some negative feedback for JMF:
\begin{itemize}
\item A lot of codecs such as MPEG-4, MPEG-2, RealAudio and WindowsMedia are not supported, MP3 only as plug-in
\item No maintenance or extension by Oracle, it is dead
\item No editing functionality, i.e. modification of multimedia content
\item Performance packs only for just a few platforms
\end{itemize}

%***********************************************************************************************

\paragraph{Basic concepts of the API}
\label{sec:BasicAPIConcepts}

Reading of multimedia data is abstracted using \texttt{DataSources}, while output goes to \texttt{DataSinks}. No specifics of supported formats are provided for direct API access, they can just be played, processed and transcoded, while the latter is not supported for all formats. A \texttt{Manager} class is the primary API for JMF users.\footnote{see \cite{WikJMF}.}

The API documentation shows that JMF is quite complex and essentially time- and event-based.\footnote{See \cite{JMFDoc}.} It offers possibilities to read raw binary data via a method \texttt{read} of \texttt{PullInputStream}. However, JMF controls processing starting at the source, i.e. from a file or stream.

%***********************************************************************************************

\subsubsection{JavaSound}
\label{sec:JavaSound}

JavaSound is Oracle's sound processing library. It has some things in common with  JMF, but can be considered quite low-level, as it also offers modification functionality for audio data. It also supports MIDI devices.\footnote{See \cite{WikJavaSound}.} It can also be considered dead, unfortunately.

%***********************************************************************************************

\paragraph{Basic concepts:}
\label{sec:BasicConcepts}

JavaSound essentiall offers the classes \texttt{Line} (representing an element in the audio processing pipeline), the derived classes \texttt{Clip} (for playing audio data) and \texttt{Mixer} (for editing audio data). The library can read from streams, files as well as in-memory bytes. It also offers ``transcoding'' functionality to convert between different formats.

%===============================================================================================
%		Basic Terms
%===============================================================================================

\chapter{Basic Terms}
\label{sec:BasicTerms}

%===============================================================================================
%		Eigentlicher Start des Kapitels
%===============================================================================================

Here we define basic terms used throughout the whole design concept. Most of them come from \cite{MetaComp}, pages 19 to 29, where even more terms are defined.

All terms are based on a a domain model for container and metadata, as defined in \cite{MetaComp}. A domain model extended for our needs is shown in the following figure - it shows all relevant terms and their relations as an overview:
\OpenIssue{Add domain model figure}

%-----------------------------------------------------------------------------------------------

\section{Metadaten}
\label{sec:Metadata}

Metadata in this document is short for digital metadata that are not necessary to parse the actual described (audio, video or image) data. Metadata semantically and structurally describes other data. The goal of \LibName{} is especially reading of metadata for audio and video data sets, e.g. title, artist etc. The structure of metadata is defined by a \TERMmetadataFormat{}.

If it is specifically about technical metadata needed to parse a data structure, e.g. in the container header,  we call it \emph{Parsing Metadata}.

%-----------------------------------------------------------------------------------------------

\section{\TERMdataFormat{}e, \TERMmetadataFormat{}e und \TERMcontainerFormat{}e}
\label{sec:DataFormats}

A \TERMdataFormat{} specifies the structure and interpretation
of data: Which bytes of which value and order have what kind of meaning?
Usually, a data format describes how a consecutive block of bytes (i.e. a \TERMdataBlock{}) is built up by a number of so-called \TERMfield{} or child \TERMdataBlock{}.

\TERMmetadataFormat{}s are data formats that define the structure of digital metadata. Examples include:
\begin{itemize}
	\item ID3v1
	\item ID3v2.3
	\item APEv1
	\item MPEG-7
	\item RDF/XML
	\item VorbisComment
	\item and others ...
\end{itemize}

\TERMcontainerFormat{}s are special \TERMdataFormat{}s optimized for storing, transporting, editing and seeking multimedia \TERMpayload{} data. Examples are:
\begin{itemize}
	\item MP3
	\item Ogg
	\item TIFF
	\item QuickTime
	\item JPEG 2000
	\item PDF
	\item and others...
\end{itemize}

An example for other \TERMdataFormat{}s is HTML. It is neither called a \TERMmetadataFormat{} nor a \TERMcontainerFormat{}. XML is a \TERMdataFormat{} that itself can be used to define further XML \TERMdataFormat{}s. Some XML \TERMdataFormat{}s are \TERMmetadataFormat{}s, e.g. MPEG-7, MPEG-21 or P\_Meta.

%-----------------------------------------------------------------------------------------------

\section{\TERMtransformation{}en}
\label{sec:DataTransformations}

A \TERMdataFormat{} may define \TERMtransformation{}s. A \TERMtransformation{} describes a way how read or to be written data needs to be transformed to fulfill specific needs. You can envision this as kind of encoding of the data. In contrast to the fixed data format specification which describes in detail how binary data is coded and needs to be interpreted, \TERMtransformation{}s are optional features that are dynamically applied to certain areas of the data. Partly, \TERMtransformation{}s can also be defined by users of the data. Examples are the \TERMtransformation{}s defined by ID3v2: Unsynchronization, Encryption and Compression.

%-----------------------------------------------------------------------------------------------

\section{\TERMdataBlocks{}}
\label{sec:DataBlocks}

A \TERMdataBlock{} is a sequence of bytes that together form a logical unit in terms of the underlying \TERMdataFormat{}. Each \TERMdataBlock{} belongs to exactly one \TERMdataFormat{}. It can be assigned a current length in bytes. There are several concrete types of \TERMdataBlock{}s that are described in the following sections.

%***********************************************************************************************

\subsection{\TERMcontainer{}: \TERMpayload{}, \TERMheader{}, \TERMfooter{}}
\label{sec:Containers}

An important type of \TERMdataBlock{} is a \TERMcontainer{}: It consists of an optional \TERMheader{}, exactly one \TERMpayload{} and maybe an optional \TERMfooter{}. All of these are \emph{child} \TERMdataBlock{}s, meaning that a \TERMcontainer{} is built-up by these three blocks.

\TERMcontainer{}s are a common concept for container and metadata formats: The \TERMheader{} describes the \TERMcontainer{} in terms of its length, size and other properties. The \TERMpayload{} contains the interesting data, e.g. the multimedia data to be played. A \TERMfooter{} allows for backwards or reverse reading. Most of the time, a \TERMcontainer{} is typed with its id, i.e. the id defines the kind and structure of data block. Furthermore, most of \TERMdataFormat{}s specify a general structure of a \TERMcontainer{} so that user-defined new \TERMcontainer{}s can be added, i.e. the format is extensible.

%***********************************************************************************************

\subsection{\TERMtag{}}
\label{sec:Tag}

A \TERMtag{} is a special \TERMcontainer{} whose purpose is to store metadata. It can either belong to a standalone \TERMmetadataFormat{} ore to a more general \TERMcontainerFormat{}. Especially audio metadata formats use this term when talking about such a \TERMdataBlock{} in a file or \TERMmediaStream{}, e.g. the ID3 or APE \TERMtag{}s.

The following figure shows the basic structure of a \TERMtag{}, showing other basic terms:

\begin{figure}[H]
\centering
\includegraphics[width=1.00\textwidth]{figures/I_TagStructure.pdf}
\caption{Structure of a \TERMtag{}}
\label{fig:5_3_SCH_Tag}
\end{figure}

The most important parts of a \TERMtag{} are the \TERMattribute{}s.

%***********************************************************************************************

\subsection{\TERMattribute{}}
\label{sec:Attribute}

An \TERMattribute{} is a part of a \TERMtag{} that contains the valuable metadata information in a key-value manner. Common examples are artist, title, album, composer etc. of a piece of audio. Often, an \TERMattribute{} is also a \TERMcontainer{} in a sense that it has a \TERMheader{}. The \TERMheader{} may help to define the type (artist, title, album) of the \TERMattribute{} as well as the size of the payload. The \TERMpayload{} contains the actual information in an encoded way, e.g. the name of the artist or title of the piece of audio.

Most of the \TERMattribute{}s have a simple main value that can be given. However, there are also more complex \TERMattribute{}s that consists of many values in form of child \TERMdataBlock{}s or \TERMfield{}s.

In each metadata format, an \TERMattribute{} has a specific name, e.g.:
\begin{itemize}
	\item ID3v1, Lyrics3: Field
	\item ID3v2: Frame
	\item APE: Item
	\item Matroska: SimpleTag
	\item VorbisComment: User Comment
\end{itemize}

In \TERMcontainerFormat{}s, the \TERMattribute{}s are often \TERMcontainer{}s defined by the \TERMcontainerFormat{}.

%***********************************************************************************************

\subsection{\TERMfield{}s}
\label{sec:Fields}

A \TERMfield{} is a sequence of bits that together have a specific meaning in a given \TERMdataFormat{}. The \TERMdataFormat{} describes how a specific \TERMdataBlock{} is built up by a specific sequence of \TERMfield{}s. A \TERMfield{} has a range of possible values and
interpretations of these values. Often, one part of the value range is defined as ``reserved'' to ensure a bit of flexibility in extending the data format.

%-----------------------------------------------------------------------------------------------

\subsection{\TERMsubject{}}
\label{sec:Subject}

A \TERMsubject{} represents a thing a \TERMtag{} describes, i.e. a part of a file, a piece of audio, a web resource or even a thing existing in reality. Often, a \TERMtag{} contains metadata for the current \TERMmedium{}, not explicitly referring to a more specific \TERMsubject{}.

%-----------------------------------------------------------------------------------------------

\section{\TERMmedium{}}
\label{sec:Medium}

A medium is the place where data \TERMdataBlock{}s are physically persisted and accessible. This may be a file, a \TERMmediaStream{} or even plain memory.

%===============================================================================================
%		Anforderungen
%===============================================================================================

\chapter{Anforderungen und Ausschlüsse}
\label{sec:Requirements}

Hier werden all expliziten Anforderungen an die Bibliothek \LibName{} in Version \LibVersion{} sowie auch explizite Ausschlüsse dargestellt. Ausschlüsse dienen dafür, explizit klarzumachen, welche Themen (auf potentiell bliebig lange Zeit) nicht unterstützt werden. Davon abzugrenzen sind bereits bekannte (ggf. sogar notwendige) Erweiterungen, die aber nicht in dieser Version verfügbar sind, sondern absehbar in einer folgenden Version umgesetzt werden sollen. Das sind (potentielle) Features, die auf eine spätere Version verschoben worden sind. Diese sind im Abschnitt \SectionLink{sec:FuerSpaeter} beschrieben.

%-----------------------------------------------------------------------------------------------
%		ANF 001
%-----------------------------------------------------------------------------------------------

\section{ANF 001: Metadaten Menschenlesbar lesen und schreiben}
\label{sec:MetadatenLesenUndSchreiben}

Metadaten sollen in \emph{menschenlesbarer Form} gelesen und geschrieben werden können. D.h. der Anwender der Library wird nicht genötigt, binäre Repräsentationen der Daten zu erzeugen, um sie schreiben zu können, bzw. binäre Daten zu interpretieren. 

\textbf{Begründung:} Dies ist eine generelle Kernfunktionalität der Library.

Eine Liste der unterstützten Formate findet sich in \SectionLink{sec:Features}.

%-----------------------------------------------------------------------------------------------
%		ANF 002
%-----------------------------------------------------------------------------------------------

\section{ANF 002: Containerformate lesen}
\label{sec:ANF002ContainerformateLesen}

Populäre bzw. verbreitete Containerformate müssen gelesen werden können.

\textbf{Begründung:} Metadaten sind oft in Containerformaten eingebettet bzw. fest in deren Spezifikation verankert. Zudem müssen Container-Segmente erkannt werden können, um sie zu überspringen und den eigentlichen Anfang der Metadaten finden zu können.

%-----------------------------------------------------------------------------------------------
%		ANF 003
%-----------------------------------------------------------------------------------------------

\section{ANF 003: Spezifikation unterstützter Metadaten- und Containerformate erfüllen}
\label{sec:ANF003SpezifikationUnterstuetzterMetadatenUndContainerformateErfuellen}

Sofern eine Spezifikation eines unterstützten Metadaten- bzw. Containerformates vorliegt, muss diese vollständig unterstützt werden. Es muss vollständigen Zugriff auf alle unterstützten Features des Datenformates möglich sein.

\textbf{Begründung:} So wird sichergestellt, dass spezifikationskonforme Metadaten geschrieben werden, die auch von anderen Libraries bzw. Anwendungen wieder gelesen werden können. Zudem kann der Nutzer der Library alle Features des jeweiligen Formates ausnutzen, ohne wiederum allzu viel Eigenimplementierung leisten zu müssen. Dies ist auch eine Differenzierungsmöglichkeit gegenüber anderen Libraries.

%-----------------------------------------------------------------------------------------------
%		ANF 004
%-----------------------------------------------------------------------------------------------

\section{ANF 004: Zugriff auf alle Rohdaten über die Library}
\label{sec:ANF004ZugriffAufAlleRohdatenUeberDieLibrary}

Zusätzlich zum Zugriff auf menschenlesbare Metadaten (\SectionLink{sec:MetadatenLesenUndSchreiben}) soll es ebenso möglich sein, alle Rohdaten aub Byteebene zu lesen. Es soll feingranularer Zugriff auf alle Felder der Binärdaten möglich sein.

\textbf{Begründung:} So können Anwender selbst ein Parsing implementieren, ohne die high-level-Funktionen nutzen zu müssen. Sie können selbst auf Byte- und Bitebene Daten manipulieren und auslesen. Ein Zugriff auf die Binärdaten ist möglich (wenn nötig), ohne wiederum einen eigenen Umweg gehen zu müssen, z.B. durch erneutes Lesen und Parsen der Daten.

%-----------------------------------------------------------------------------------------------
%		ANF 005
%-----------------------------------------------------------------------------------------------

\section{ANF 005: Performance vergleichbar mit anderen Java-Metadaten-Libraries}
\label{sec:ANF005PerformanceVergleichbarMitAnderenJavaMetadatenLibraries}

Die Performance der Library soll gleichwertig oder besser als die anderen Java-Metadaten-Libraries sein. Hierfür müssen die Vergleichslibraries benannt und ein entsprechender Benchmark definiert und durchgeführt werden.

\textbf{Begründung:} Die Library soll ähnlich performant wie bestehende Lösungen der idealerweise performanter sein, um hier kein Argument gegen ihren Einsatz zu liefern.

%-----------------------------------------------------------------------------------------------
%		ANF 006
%-----------------------------------------------------------------------------------------------

\section{ANF 006: Fehlererkennung, Fehlertoleranz, Fehlerkorrektur}
\label{sec:ANF006FehlererkennungFehlertoleranzFehlerkorrektur}

Ergänzend zur \SectionLink{sec:ANF003SpezifikationUnterstuetzterMetadatenUndContainerformateErfuellen} muss die Library aber auch \emph{fehlertolerant} sein, so weit möglich. D.h. u.a., das Spezifikationsverstöße und fehlerhafte Parsing-Metadaten erkannt werden, und dies - soweit nicht unumgänglich - nicht zum Abbruch des Parsens mit einem Fehler endet. Verstöße werden protokolliert und wenn möglich automatisch korrigiert (optional, wenn es der Library-Anwender wünscht).

\textbf{Begründung:} Altanwendungen oder andere Libraries schreiben Datenformate manchmal nicht 100\% spezifikationskonform. Zudem sind nicht alle Spezifikationen eindeutig oder genau genug, sodass Varianten entstehen könnten. Trotz Vorliegen fehlerhafter Daten soll der Anwender der Library in die Lage versetzt werden, Daten dennoch auslesen und ggf. sogar korrigieren zu können.

%-----------------------------------------------------------------------------------------------
%		ANF 007
%-----------------------------------------------------------------------------------------------

\section{ANF 007: Extensibility for new Metadata and Container Formats}
\label{sec:ANF007ErweiterbarkeitUmNeueMetadatenUndContainerformate}

\LibName{} must be comfortably extensible with new container or metadata formats. As the minimum level, easy extensibility by the library developers must be possible. As the maximum level of extensibility, also end users with programming experience must be able to easily write extensions without too much configuration or boilerplate code.

\textbf{Rationale:} New metadata formats are developed and are available over and over again. The extensibility ensures a longer life time of the library and allows easier maintenance by the library developers. In the maximum level ``Extensibility by end users'', this is a clear differntiation criterion to other libraries that do not offer this level of extensibility.

%-----------------------------------------------------------------------------------------------
%		ANF 008
%-----------------------------------------------------------------------------------------------

\section{ANF 008: Lesen und Schreiben großer Datenblöcke}
\label{sec:ANF009LesenSchreibenGrosse}

\LibName{} muss das Lesen und Schreiben sehr großer Datenmengen effizient unterstützen, und dabei Mechanismen verwenden, um OutOfMemoryErrors zu vermeiden.

\textbf{Begründung:} Besonders im Video-Bereich können teilweise gigabyte-große Nutzdaten vorkommen. Die Länge der Nutztdaten muss korrekt interpretiert werden können. Wegen \SectionLink{sec:ANF004ZugriffAufAlleRohdatenUeberDieLibrary} muss auch das Lesen und Schreiben der Nutzdaten unterstützt werden, ohne dass Speicher knapp wird, d.h. ein etappenweises Lesen und Schreiben o.ä. muss möglich sein. Dies ist auch ein Differenzierungsmerkmal zu anderen Libraries, die dies ggf. gar nicht unterstützen können.

%-----------------------------------------------------------------------------------------------
%		ANF 009
%-----------------------------------------------------------------------------------------------

\section{ANF 009: Selective Format Choice}
\label{sec:ANF010SchreibenInAnderesAusgabemediumUnterstützt}

An application using \LibName{} must be able to selectively choose these formats that it wants to support. This is not only necessary for runtime, but also for the library extension packages it wants to use.

\textbf{Rationale:} Audio applications do not need extensions for video or image formats. Applications can minimize the runtime and memory overhead by choosing as few extensions as really needed.

%-----------------------------------------------------------------------------------------------
%		AUS 001
%-----------------------------------------------------------------------------------------------

\section{AUS 001: Lesen aus Media Streams}
\label{sec:AUS009LesenAusStreams}

Ein Lesen von Metadaten oder Containerdaten aus Streams (streaming media) wird nicht explizit unterstützt. Es können im Design Möglichkeiten zur aktiven Unterstützung vorgesehen werden, dies ist aber nicht zwingend erforderlich.

\textbf{Begründung:} Kombinierte Anwendungen (Recorder bzw. Player) machen für diesen Fall mehr Sinn und sind auch weitgehend verfügbar. Die zusätzliche Unterstützung für Streaming könnte das Design verkomplizieren. Es ist aktuell unklar, wie dies umzusetzen wäre.

%-----------------------------------------------------------------------------------------------
%		AUS 002
%-----------------------------------------------------------------------------------------------

\section{AUS 002: Lesen von XML-Metadaten}
\label{sec:AUS010LesenVonXMLMetadaten}

Es gibt auch XML-Metadatenformate. Üblicherweise werden diese aber nicht in Multimedia-Daten eingesetzt, da sie sehr ``verbos'' sein können. Hier sind weiterhin die binären Metadatenformate die Platzhirsche. Die Unterstützung von XML wird nicht im Kern der Library vorgesehen.

\textbf{Begründung:} Der Versuch, sowohl binäre als auch XML-Formate über die gleiche API oder gar Implementierung zu unterstützen, kann zu einem sehr komplizierten Design führen. Java bietet viele sinnvolle Standard-Möglichkeiten zum Parsen und zum Schreiben von XML-Metadaten. Evtl. könnten diese in Ausbaustufen in einer Implementierung (hinter der gleichen API-Schnittstelle) in einer späteren Ausbaustufe unterstützt werden.

%-----------------------------------------------------------------------------------------------
%		AUS 003
%-----------------------------------------------------------------------------------------------

\section{AUS 003: No User Extensions for \LibName{} Media}
\label{sec:AUS01220LesenVonXMLMetadaten}

Extending \LibName{} with new media to support - on top of the out-of-the box supported media - is not supported.

\textbf{Rationale:} The mechanisms available should cover 80 to 90 percent of the use cases. Extensibility by new media might increase the complexity of \LibName{} itself and the extension mechanism in specific, without adding real-world use cases really needing it. It is currently not clear which media beyond streams, byte arrays and files might be candidates for extending \LibName{}. Should new media make sense in future, a new core release can be created to also support media extensions.

%===============================================================================================
%		Reference Examples
%===============================================================================================

\chapter{Reference Examples}
\label{sec:ReferenceExamples}

To proof conformance with the \LibName{} requirements, a set of (mostly) real-life examples for all supported formats is used. The examples are used to illustrate design decisions and also to verify them. In this chapter, these examples are presented for short. The concrete detailed structures of each data format is described in \cite{MetadataCompendium}.

Note that the sizes of the data blocks in the following illustrating example figures do not have any specific meaning.

%-----------------------------------------------------------------------------------------------
%		Example 1: MP3 File with ID3v2.3 and ID3v1.1
%-----------------------------------------------------------------------------------------------

\section{Example 1: MP3 File with ID3v2.3, ID3v1.1 and Lyrics3}
\label{sec:Example1MP3FileWithID3v23AndID3v11}

The following figure shows the first example, an MP3 file with three \TERMtag{}s, ID3v2.3, Lyrics3v2 and ID3v1.1. All are located at the end of the file:

\begin{figure}[H]
\centering
\includegraphics[width=1.00\textwidth]{figures/I_Example1.pdf}
\caption{Example 1: MP3 file with two tags}
\label{fig:Example1MP3filewithtwotags}
\end{figure}

The ID3v2.3 tag has several frames, including two \texttt{GEOB} frames. Furthermore, it has some padding within. Each of the MP3 frames corresponds to the MPEG-1 elementary stream audio format.

%-----------------------------------------------------------------------------------------------
%		Example 2: MP3 File with two ID3v2.4 Tags
%-----------------------------------------------------------------------------------------------

\section{Example 2: MP3 File with two ID3v2.4 Tags}
\label{sec:Example2MP3FileWithID3v23AndID3v11}

The following figure shows the second example, an MP3 file with two ID3v2.4 \TERMtag{}s, one at the beginning, the other one at the end of the file:

\begin{figure}[H]
\centering
\includegraphics[width=1.00\textwidth]{figures/I_Example2.pdf}
\caption{Example 2: MP3 file with two ID3v2.4 tags}
\label{fig:Example1MP3filewithtwoID3tags}
\end{figure}

The two ID3v2.4 tags are virtually connected by a \texttt{SEEK} frame. Both have several specialties described in \cite{MetadataCompendium}.

%-----------------------------------------------------------------------------------------------
%		Example 3: MP3 Media Stream with periodic ID3v2.3 Tags
%-----------------------------------------------------------------------------------------------

\section{Example 3: MP3 Media Stream with periodic ID3v2.3 Tags}
\label{sec:Example3MP3FileWithID3v23AndID3v11}

The following figure shows the third example, an MP3 media stream with wildly scattered or periodic ID3v2.3 \TERMtag{}s. The figure shows that start of listening to the stream may also be in the middle of an MP3 block:

\begin{figure}[H]
\centering
\includegraphics[width=1.00\textwidth]{figures/I_Example3.pdf}
\caption{Example 3: MP3 Media Stream with periodic ID3v2.3 Tags}
\label{fig:Example3MP3filewithtwoID3tags}
\end{figure}

%-----------------------------------------------------------------------------------------------
%		Example 4: Ogg Bitstream with Theora and VorbisComment
%-----------------------------------------------------------------------------------------------

\section{Example 4: Ogg Bitstream with Theora and VorbisComment}
\label{sec:Example4MP3FileWithID3v23AndID3v11}

The following figure shows the fourth example, an Ogg bitstream that contains Theora payload data with a corresponding vorbis comment:

\begin{figure}[H]
\centering
\includegraphics[width=1.00\textwidth]{figures/I_Example4.pdf}
\caption{Example 4: Ogg Bitstream with Theora and VorbisComment}
\label{fig:Example4MP3filewithtwoID3tags}
\end{figure}

The example is complex on first sight. In an Ogg bitstream, physical and logical structure are not necessarily the same. The physical structure is built by pages, packets and segments, while the logical structure is the structure of the wrapped data. We took theora video data as an example, but its basically arbitrary, as the codec does not really matter. What matters is where the Vorbis Comment, one of the supported data formats, is stored. This unfortunately depends on the embedded codec. In this example, the vorbis comment starts in the second page and spans over two packets. The second of these packets spans over two Ogg pages.

% %-----------------------------------------------------------------------------------------------
% %		Example 5: TIFF RGB image file
% %-----------------------------------------------------------------------------------------------

% \section{Example 5: TIFF RGB image file with Exif IFD}
% \label{sec:Example5MP3FileWithID3v23AndID3v11}

% An example RGB image TIFF file with an Exif IFD is modelled in the following figure:\footnote{The example is based on the figure of \cite{ExifSpec}, page 9.}

% \begin{figure}[H]
%\centering
%\includegraphics[width=1.00\textwidth]{figures/I_Example5.pdf}
%\caption{Example 5: TIFF RGB image file with Exif IFD}
%\label{fig:Example5MP3filewithtwoID3tags}
% \end{figure}

% Note that Exif is \emph{not a supported format} for \LibName{} currently. However, the presence of an Exif IFD must not be a problem for \LibName{}, of course.

% The example contains two image data parts, in this example stored after each other. The first image part is just a thumbnail image while the second one stores the real image data. The figure shows the pointered structure of the file as IFD fields often point to a byte offset in the file where the actual data is stored.

% %-----------------------------------------------------------------------------------------------
% %		Example 6: RIFF WAVE File
% %-----------------------------------------------------------------------------------------------

% \section{Example 6: RIFF WAVE File}
% \label{sec:Example6MP3FileWithID3v23AndID3v11}

% An example RIFF file with WAVE sound contents is shown in the following figure:

% \begin{figure}[H]
%\centering
%\includegraphics[width=1.00\textwidth]{figures/I_Example6.pdf}
%\caption{Example 6: RIFF WAVE File}
%\label{fig:Example6MP3filewithtwoID3tags}
% \end{figure}

% The top-level root chunk contains a fact chunk, a format chunk, a list of wave data chunks and finally a \texttt{LIST} info chunk in its payload. The \texttt{LIST} info chunk can be considered as \TERMtagBasic{}. It contains \texttt{INAM}, \texttt{IART} and \texttt{ICRD} sub-chunks.

% %-----------------------------------------------------------------------------------------------
% %		Example 7: QuickTime File
% %-----------------------------------------------------------------------------------------------

% \section{Example 7: QuickTime File}
% \label{sec:Example7MP3FileWithID3v23AndID3v11}

% An example QuickTime file is shown in the following figure:

% \begin{figure}[H]
%\centering
%\includegraphics[width=1.00\textwidth]{figures/I_Example7.pdf}
%\caption{Example 7: QuickTime File}
%\label{fig:Example7MP3filewithtwoID3tags}
% \end{figure}

% A QuickTime file can easily get very complex. The example contains the \texttt{ftyp}, \texttt{moov}, \texttt{mdat} and \texttt{free} atoms as top-level atoms. The \texttt{mdat} atom contains the media data and is not further detailed in the example. It is preceded by a wide atom to enable easy extension to a header indicating more than $2^{32}$ bytes media atom size.

% The example defines two tracks in the movie atom. One of these contains a user data atom which contains key-value metadata. The other track contains the QuickTime \texttt{meta} atom also defining metadata, but in a different way.

% The example shows that the \texttt{moov} atom itself additionally contains a \texttt{meta} and user data atom describing the whole file.

% %-----------------------------------------------------------------------------------------------
% %		Example 8: Matroska File
% %-----------------------------------------------------------------------------------------------

% \section{Example 8: Matroska File}
% \label{sec:Example8MP3FileWithID3v23AndID3v11}

% An example Matroska file is shown in the following figure:

% \begin{figure}[H]
%\centering
%\includegraphics[width=1.00\textwidth]{figures/I_Example8.pdf}
%\caption{Example 8: Matroska File}
%\label{fig:Example8MP3filewithtwoID3tags}
% \end{figure}

% The example has two Cluster elements that store the actual media data. These are not further detailed in the example. The metadata in the example is complex: There are two top-level Tags elements, the first one contains two Tag elements, the second one only a single Tag element. Each of the Tag elements has child SimpleTag elements. The first Tag contains a Targets sub-element that points to two tracks of the file. Tag 3 only contains SimpleTags. However, the first SimpleTag contains nested SimpleTags.

% %-----------------------------------------------------------------------------------------------
% %		Example 9: Arbitrary XML
% %-----------------------------------------------------------------------------------------------

% \section{Example 9: Arbitrary XML}
% \label{sec:Example9MP3FileWithID3v23AndID3v11}

% \LibName{} is required to handle arbitrary XML data, too. The following short file is taken as an example:

% \begin{lstlisting}
% <?xml version="1.0" encoding="UTF-8"?>
% <!DOCTYPE ComponentConfiguration [ 

% <!ELEMENT ComponentDescriptor (Service+)>

% <!ATTLIST id NAME CDATA #REQUIRED>

% ]> 
% <cconf:ComponentConfiguration
% xmlns:cconf="www.easytag.de/XMLSchema_v1_0"
% 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
% 	xsi:schemaLocation="www.easytag.de/XMLSchema_v1_0 ComponentConfiguration.xsd">
% 	<ComponentDescriptor id="a">
% 		<ProviderPath>bin/</ProviderPath>
% 		<Service>
% 			<Interface>de.je.registry.export.compdummies.a.export.TestInterfaceCompA1</Interface>
% 			<Provider>de.je.registry.compdummies.a.impl.TestImplCompA1</Provider>
% 		</Service>
% 		<Service>
% 			<Interface>de.je.registry.export.compdummies.a.export.TestInterfaceCompA2</Interface>
% 			<Provider>de.je.registry.compdummies.a.impl.TestImplCompA2</Provider>
% 		</Service>
% 	</ComponentDescriptor>
% 	<ComponentDescriptor id="b">
% 		<ProviderPath>bin/</ProviderPath>
% 		<Service>
% 			<Interface>de.je.registry.export.compdummies.b.export.TestInterfaceCompB1</Interface>
% 			<Provider>de.je.registry.compdummies.b.impl.TestImplCompB1</Provider>
% 		</Service>
% 	</ComponentDescriptor>
% 	<ComponentDescriptor id="c">
% 		<ProviderPath>bin/</ProviderPath>
% 		<Service>
% 			<Interface>de.je.registry.export.compdummies.c.export.TestInterfaceCompC1</Interface>
% 			<Provider>de.je.registry.compdummies.c.impl.TestImplCompC1</Provider>
% 		</Service>
% 	</ComponentDescriptor>
% 	<ComponentDescriptor id="d">
% 		<ProviderPath>bin/</ProviderPath>
% 		<Service>
% 			<Interface>de.je.registry.export.compdummies.d.export.XYZ</Interface>
% 			<Provider>de.je.registry.compdummies.d.impl.XYZImpl</Provider>
% 		</Service>
% 	</ComponentDescriptor>
% </cconf:ComponentConfiguration>
% \end{lstlisting}

% The example contains most XML elements: DTD, Elements, attributes, namespaces and of course the XML header.

% %-----------------------------------------------------------------------------------------------
% %		Example 10: Arbitrary XHTML with Meta Elements and RDFa
% %-----------------------------------------------------------------------------------------------

% \section{Example 10: Arbitrary XHTML with Meta Elements and RDFa}
% \label{sec:Example10MP3FileWithID3v23AndID3v11}

% \LibName{} is required to handle arbitrary XHTML data, and especially XHTML meta elements and embedded RDFa. All of this is contained in the following example:

% \begin{lstlisting}
% <?xml version="1.0" encoding="UTF-8"?>
% <!DOCTYPE html
%   PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
%   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
% <html xmlns="http://www.w3.org/1999/xhtml"
%     version="XHTML+RDFa 1.0"
% 	 xmlns:biblio="http://example.org/"
%     xmlns:dc="http://purl.org/dc/elements/1.1/"
%     xmlns:cal="http://www.w3.org/2002/12/cal/ical#"
%  	 xmlns:foaf="http://xmlns.com/foaf/0.1/"
%     xml:lang="en"
%      profile="http://example.org/profil.html">
%   <head>
%     <title>Books by Marco Pierre White</title>
%     <!-- There is no about attribute here which means the predicate dc:creator with object (i.e. value) "Mark Birbeck" refers to the current document as a subject -->
%     <meta property="dc:creator" content="Mark Birbeck" />
%     <!-- Another example of a predicate that expresses a relationship "foaf:topic" to the specified URI. -->
%     <link rel="foaf:topic" href="http://www.formsPlayer.com/#us" />
% 	 <link rel="foaf:primaryTopic" href="#bbq" />
% 	<title>Beschreibung der Seite</title>
% 	<meta name="Typ" scheme="MIME-Type" content="image/svg+xml">
% 	<meta name="author" content="Anna Lyse">
% 	<meta http-equiv="expires" content="Sat , 01 Dec 2001 00:00:00 GMT">
% 	<meta name="keywords" lang="de" content="Ferien , Griechenland ,
% 		Sonnenschein">
% 	<meta name="keywords" lang="en-us" content="vacation , Greece , sunshine">
% 	<meta name="keywords" lang="en" content="holiday , Greece , sunshine">
% 	<meta name="keywords" lang="fr" content="vacances , Gr&egrave;ce , soleil">
% 	<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
% 	<meta http-equiv="Content-Script-Type" content="text/javascript">

% 	<meta http-equiv="PICS-Label" content='(PICS-1.1 "http://www.gcf.org/v2.5"
% 		labels on "1994.11.05T08:15-0500"
% 		unti l "1995.12.31T23:59-0000"
% 		for "http://w3c.org/PICS/Overview.html"
% 		ratings ( suds 0.5 density 0 color/hue 1) ) '>
%   </head>
%   <body>
%     I think White's book
%     <!-- Here comes the first subject embedded in a span element. It refers to a specific datatype using typeof. It is described with the predicate dc:title whose object (i.e. value) is
%     the contents of the span element. -->
%     '<span about="urn:ISBN:0091808189" typeof="biblio:book"
%            property="dc:title">
%       Canteen Cuisine
%     </span>'
%     is well worth getting since although it's quite advanced stuff, he
%     makes it pretty easy to follow. You might also like
%     <!-- The second subject whose dc:description is given. -->
%     <span about="urn:ISBN:1596913614" typeof="biblio:book"
%           property="dc:description">
%       White's autobiography
%     </span>.
%     <!-- Another subject -->
%     <p about="#bbq" typeof="cal:Vevent">
%       I'm holding
%       <span property="cal:summary">
%         one last summer barbecue
%       </span>,
%       on
%       <!-- Here the object is not the content of the span attribute but the value of the "content" attribute -->
%       <span property="cal:dtstart" content="2007-09-16T16:00:00-05:00"
%             datatype="xsd:dateTime">
%         September 16th at 4pm
%       </span>.
%     </p>
% </body>
% </html>
% \end{lstlisting}

% The example is not real but constructed from various sources. It contains as much different elements as possible:
% \begin{itemize}
% 	\item Some meta elements with a @name attribute
% 	\item Some meta elements with a @http-equiv attribute
% 	\item A meta element containing PICS metadata. PICS is not directly supported in \Lib{}. However, the generic meta elements must be parsed correctly, no matter what they contain.
% 	\item Some meta elements using specific namespaces or profiles
% 	\item RDFa metadata
% \end{itemize}

% %-----------------------------------------------------------------------------------------------
% %		Example 11: An RDF/XML File
% %-----------------------------------------------------------------------------------------------

% \section{Example 11: An RDF/XML File}
% \label{sec:Example11MP3FileWithID3v23AndID3v11}

% \begin{lstlisting}
% <?xml version="1.0" encoding="UTF-8"?>
% <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
%          xmlns:pcv="http://prismstandard.org/namespaces/pcv/1.0/"
%          xmlns:dc="http://purl.org/dc/elements/1.1/"
%          xml:base="http://travel.example.com/"
%          xmlns:s="http://example.org/students/vocab#"
%          xmlns:exterms="http://www.example.org/terms/">

%   <rdf:Description rdf:about="/2000/08/Corfu.jpg">
%     <dc:identifier rdf:resource="/content/2357845" />
%     <dc:creator>
%       <pcv:Descriptor rdf:about="/emp3845">
%         <pcv:label>John Peterson</pcv:label>
%       </pcv:Descriptor>
%     </dc:creator>
%     <dc:coverage>
%       <pcv:Descriptor
%           rdf:about="http://prismstandard.org/vocabs/ISO-3166/GR">
%         <pcv:label xml:lang="en">Greece</pcv:label>
%         <pcv:label xml:lang="fr">Grece</pcv:label>
%       </pcv:Descriptor>
%     </dc:coverage>
%   </rdf:Description>

%   <rdf:Description rdf:about="/2000/08/Corfu.jpg">
%     <dc:identifier rdf:resource="/content/2357845" />
%     <dc:creator>
%     	Michael
%     </dc:creator>
%   </rdf:Description>
  
%    <rdf:Description rdf:about="http://example.org/courses/6.001">
%       <s:students rdf:parseType="Collection">
%          <rdf:Description rdf:about="http://example.org/students/Amy"/>
%          <rdf:Description rdf:about="http://example.org/students/Mohamed"/>
%          <rdf:Description rdf:about="http://example.org/students/Johann"/>
%       </s:students>
%    </rdf:Description>

%   <rdf:Description rdf:about="http://www.example.com/2002/04/products#item10245">
%      <exterms:weight rdf:parseType="Resource">
%        <rdf:value rdf:datatype="&xsd;decimal">2.4</rdf:value>
%        <exterms:units rdf:resource="http://www.example.org/units/kilograms"/>
%      </exterms:weight>
%   </rdf:Description>

% </rdf:RDF>
% \end{lstlisting}

% The example contains several rdf:Description elements, even two referring to the same subject. We also have applications of the rdf:parseType, rdf:datatype and rdf:resource attributes. There are also some nested descriptions.

% %-----------------------------------------------------------------------------------------------
% %		Example 12: An XMP File
% %-----------------------------------------------------------------------------------------------

% \section{Example 12: An XMP File}
% \label{sec:Example12MP3FileWithID3v23AndID3v11}

% The following listing shows the XMP reference example:

% \begin{lstlisting}
% <?xpacket begin='?' id='W5M0MpCehiHzreSzNTczkc9d'?>
% <x:xmpmeta xmlns:x='adobe:ns:meta/' x:xmptk='XMPTk 2.8'>

% <rdf:RDF 
% 	xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#' 
% 	xmlns:iX='http://ns.adobe.com/iX/1.0/'>

% 	<rdf:Description about=''
% 		xmlns:xmp='http://ns.adobe.com/xap/1.0/' 
% 		xmp:Author='Jane Doe'
% 		xmp:BaseURL='http://mydoc'
% 		xmp:CreateDate='2001-08-13T10:42:24Z'
% 		xmp:CreatorTool='Microsoft Visual C++ for Windows'
% 		xmp:Format='text/xml'
% 		xmp:MetadataDate='2001-08-13T10:42:24Z'
% 		xmp:ModifyDate='2001-08-13T11:02:13Z'
% 		xmp:Nickname='sample'>
    
% 		<xmp:Advisory>
% 			<rdf:Bag>    
%  				<rdf:li>http://purl.org/dc/elements/1.1/ format</rdf:li>
% 				<rdf:li>http://ns.adobe.com/xap/1.0/xap/g/ NumberOfColors</rdf:li>
% 				<rdf:li>http://ns.adobe.com/xap/1.0/xap/g/img/ Resolution/stRes:units</rdf:li>
% 			</rdf:Bag>
% 		</xmp:Advisory>
  
% 		<xmp:Authors>  
% 			<rdf:Seq>
% 				<rdf:li>Jane Doe</rdf:li>
% 				<rdf:li>John Doe</rdf:li>
% 				<rdf:li>Jack Doe</rdf:li>
% 			</rdf:Seq>
% 		</xmp:Authors>
% 		<xmp:Description>
% 			<rdf:Alt>
% 				<rdf:li xml:lang='en'>This document is a sample XML file</rdf:li>
% 				<rdf:li xml:lang='fr'>Ce document est un fichier d`exemple XML</rdf:li>
% 				<rdf:li xml:lang='de'>Dieses Dokument ist eine XML Beispieldatei</rdf:li>
% 			</rdf:Alt>
% 		</xmp:Description>
  
% 		<xmp:Keywords>
% 			<rdf:Bag>
% 				<rdf:li>XMP</rdf:li>
% 				<rdf:li>Core</rdf:li>
% 				<rdf:li>Schema</rdf:li>
% 				<rdf:li>sample</rdf:li>
% 			</rdf:Bag>
% 		</xmp:Keywords>
% 		<xmp:Locale>
% 			<rdf:Bag>
% 				<rdf:li>en</rdf:li>
% 				<rdf:li>fr</rdf:li>
% 				<rdf:li>de</rdf:li>
% 			</rdf:Bag>
% 		</xmp:Locale>
  
% 		<xmp:Title>
% 			<rdf:Alt>
% 				<rdf:li xml:lang='en'>XMP Core Schema Example</rdf:li>
% 				<rdf:li xml:lang='fr'>XMP Core Schema Exemple</rdf:li>
% 				<rdf:li xml:lang='de'>XMP Core Schema Beispiel</rdf:li>
% 			</rdf:Alt>
% 		</xmp:Title>
  
% 	</rdf:Description>

% </rdf:RDF>

% </x:xmpmeta>
% <?xpacket end='r'?>

% </top_level_element>
% \end{lstlisting}

%###############################################################################################
%###############################################################################################
%
%		File end
%
%###############################################################################################
%###############################################################################################


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "jMetaDesignConcept"
%%% End: