%-----------------------------------------------------------------------------------------------
%		\COMPcomponentRegistry{} Design
%-----------------------------------------------------------------------------------------------

\section{\COMPcomponentRegistry{} Design}
\label{sec:COMPcomponentRegistryDesign}

In this section, the design of the component \COMPcomponentRegistry{} is described. Basic task of this component is the implementation of design decisions \DesLink{dd:004} and \DesLink{dd:005}.

We just give the basic design decisions here. Before the current solution, we used a relatively complex custom-made component mechanism with caching, XML configuration of interface and implementation as well as registration of the components at startup. This code was organized in an eclipse project named ``ComponentRegistry'', but was later a bit simplified later as ``SimpleComponentRegistry''. However, after realizing that the built-in Java SE \texttt{ServiceLoader} mechanism is fully suitable and even better than the ``SimpleComponentRegistry'', this mechanism is used now.

According to \DesLink{dd:005}, a component is a ``Singleton''. However, its life cycle must also be clearly:
%%%% DD --> %%%%
\DD{dd:221}
{% Titel
\COMPcomponentRegistry{} uses Java's \texttt{ServiceLoader} mechanism
}
{% Kurzbeschreibung
\COMPcomponentRegistry{} uses Java's \texttt{ServiceLoader} class to load the implementation for a given component interface. All component interfaces and their implementations need to be configured in META-INF configuration files as indicated by the Javadocs of \texttt{ServiceLoader}.
}
{% Begründung
The \texttt{ServiceLoader} mechanism is quite easy to setup and requires nearly no specific coding. No code needs to be written to read corresponding configuration. A specific description / documentation mechanism of each component at runtime is not necessary, thus it was omitted (in contrast to previous implementation).
}
{% Nachteile
Of course, \texttt{ServiceLoader} has its limitations: You might not be easily able to add components at runtime without writing additional code or not at all. And it does not have any idea of the term of a component, it just knows interfaces and implementations. But this is all not a requirement for \LibName{}.
}
%%%% <-- DD %%%%

Here is just a short summary of small amount the self-written code in \COMPcomponentRegistry{}:
%%%% DD --> %%%%
\DD{dd:222}
{% Titel
\COMPcomponentRegistry{} consists of a single non-thread-safe class for looking up implementations and cache handling
}
{% Kurzbeschreibung
\COMPcomponentRegistry{} solely consist of a single class. This class caches \texttt{ServiceLoader}s. It offers the following methods:
\begin{itemize}
\item \texttt{lookupService:} Loads a service implementation (if called the first time for an interface) and returns it, adds its \texttt{ServiceLoader} to the cache afterwards
\item \texttt{clearServiceCache:} Clears the internal cache of \texttt{ServiceLoader}s such that the next call re-reads and re-instantiates new implementations again.
\end{itemize}
The class offers this as static methods, but it is not thread-safe.
}
{% Begründung
Why do we cache \texttt{ServiceLoader}s? Because the \texttt{ServiceLoader.load} method always creates a new instance of the \texttt{ServiceLoader} class, which has the following effects:
\begin{itemize}
\item Components are singletons, thus, if two different other components need an implementation of the component at different points in time, they would get different instance of the service implementation, as they would always create a new \texttt{ServiceLoader} instance.
\item \texttt{ServiceLoader.load} does file I/O, which is not what we want every time we request a new implementation.
\end{itemize}

The method \texttt{clearServiceCache} is necessary for test cases which might need to reset the \COMPcomponentRegistry{} state after each test case. As it is a static class, this method is necessary.

Why static methods? Because we do not want to care about instantiating it, passing the same instance everywhere needed.

Why is it not thread-safe? Because the whole library is not intending to the thread-safe.
}
{% Nachteile
No disadvantages known
}
%%%% <-- DD %%%%



%###############################################################################################
%###############################################################################################
%
%		File end
%
%###############################################################################################
%###############################################################################################